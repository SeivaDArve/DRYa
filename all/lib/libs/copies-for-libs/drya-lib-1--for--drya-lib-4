#/bin/bash
# Title: Colors Boilerplate
# Description: One file that saves all colors
# Use: `source` this file to avoid repeating the same color functions on your scripts
# Use for libraries: In this file, copy the normal functions and variables to the bottom of the page and use capital letters instead
#                    F_talk is F_talk  (for example in drya-lib-4)
#                    V_txt  is V_txt   (for example in drya-lib-4)


#
#
#  INSTRUCTIONS: 
#     At the top of every script file in which this script needed, place these lines below:
#
#
#     # Sourcing DRYa Lib 1: Color schemes
#        __name__="example-to-change"  # Change to the name of the script. Example: DRYa.sh, ezGIT.sh, Patuscas.sh (Set this variable at the head of the file, next to title)
#        V_lib1=${v_REPOS_CENTER}/DRYa/all/lib/libs/drya-lib-1-colors-greets.sh
#        source $V_lib1 2>/dev/null || (read -s -n 1 -p "DRYa libs: $__name__: drya-lib-1 does not exist (error)" && echo )
#
#        # Examples: F_greet, F_greet2, F_talk, F_done, F_anyK, F_Hline, F_horizlina, F_verticline, etc... [From the repo at: "https://github.com/SeivaDArve/DRYa.git"]
#           V_greet="DRYa"
#           V_talk="DRYa: "
#           V_txt="<text-used-at-f_anyK-fx>"
#           V_hzl  # (uDev: variable that decides what is the char that is written in the horizontal line)
#  
#



# uDev: fix dependencies bugs (in case DRYa is running on a fresh install of some new OS)
# uDev: Center text Horizontally + vertically
# uDev: add fx to test if a given variable is number, letter or others
# uDev: fx to read text like chat gpt, one character at a time, slow dump of text, like pokemon on gameboy, like in between each letter of text there is a command `sleep 0.1`. Text is not dumpt at once, it is slowly diumped
# uDev: create fx that catches prompt arguments: $1 $2 $3 = $V_1 $V_2 $V_3
# uDev: create fx to increment a var: i=(($i + 1))
# uDev: add fx for `date` command
# uDev: with ANSI, move cursor up one line
# uDev: F_clear_current_line, (Apagar texto da linha atual ate ao fundo com ANSI)
#       F_count_var_size,     (saber quantas letrar tem `echo ${#variavel}`)
#       F_create_tmp_file     (dar um nome e saber que esse ficheiro tmp foi criado)
# uDev: fx com tput para apagar linha anterior inteira e comecar a escrever a partir de la
#       vatias fx para usar tput, manipular tput facilmente



function F_test_dependencie_tput {
   # Testar a existencia de ncurses-utils

   #echo "uDev"

   V_status=1
   V_status=0
}


function F_c1 {	
   # Text Color 1
   # This function is to be used:
   #  - Output of `git` when something is being cloned, pulled, pushed

   F_test_dependencie_tput
   [[ $V_status == 0 ]] && tput setaf 5  #   2>/dev/null  || (or, use ANSI colors) 
}

function F_c2 { 
   # Fx for color 2

   F_test_dependencie_tput
   [[ $V_status == 0 ]] && tput setaf 12
}

function F_c3 { 
   # Fx for color 3

   # Mentioning user input or valiable input
   # This function is to be used when something is DECLAIRED

   F_test_dependencie_tput
   [[ $V_status == 0 ]] && tput setaf 3
}

function F_c4 { 
   # Fx for color 4

   # Similar to Bold. Used in: F_talk
   # This function is to be used when something is ASKED
   F_test_dependencie_tput
   [[ $V_status == 0 ]] && tput setaf 4
}

function F_c5 { 
   # Fx for color 5

   # Similar to Bold
   F_test_dependencie_tput
   [[ $V_status == 0 ]] && tput setaf 6
}

function F_c6 { 
   # Fx for color 6

   # Used for ASCII Drya Logo, centered to the screen
   F_test_dependencie_tput
   [[ $V_status == 0 ]] && tput setaf 28
   [[ $V_status == 0 ]] && tput bold
}

function F_c7 {
   # Fx for ANSI green color

   GREEN='\033[0;32m'
   echo -en "$GREEN"
}

function F_c8 {
   # Fx for ANSI red color

   RED='\033[0;31m'
   echo -en "$RED"
}

function F_rc { 
   # Fx for color reset

   # This function is to be used when styles are to be CLEARED
   [[ $V_status == 0 ]] && tput sgr0
}

function F_colors_without_tput {
   # Text Colors before discovering '$ tput setaf'
      RESTORE=$(echo -en '\001\033[0m\002')
          RED=$(echo -en '\001\033[00;31m\002')

   # Exemplo de backspace 1: `echo -e "Texto \bArvore"` output: "TextoArvore"
   #
   # Exemplo de backspace 2: V_backspace=$'\b'
   #                         v="Texto ${v_backspace}Arvore"
   #                         echo -e "$v"
   #                         Output: "TextoArvore"

   # uDev: Criar vars de cor ANSI que usam SEMPRE um Backspace (facilita aleitura)
   #       c_bks="\b"                           # Variavel de codigo ANSI para traser o cursor um caractere para a esquerda
   #       c_vrm="\001\033[00;31m\002"          # Variavel de cor V_vrm ou c_vrm para: Vermelho
   #       c_vrm="${c_bks}\001\033[00;31m\002"  # Variavel de cor V_vrm ou c_vrm para: Vermelho (com backspace)
   #       c_rst="\001\033[00;31m\002"          # Variavel de cor V_rst ou c_rst para: Restore (reset as cores e estilos)
   #
   #       Exemplo: `echo -e "Texto: ${c_vrm} A vermelho. ${c_rst} Agora a branco"


   # Example of Text formating before discovering '$ tput'
   # > `echo ${RED}To do something, specify an argument like \"G 2\"${RESTORE}`
}  

function F_cON {
   # Fx for make cursor visible

   [[ $V_status == 0 ]] && tput cnorm
}

function F_cOFF {
   # Fx for make cursor invisible

   [[ $V_status == 0 ]] && tput civis
}

function F_greet {
   # Presents a nice visual ascii name/logo if figlet is installed
   # Presents a text massage with name/logo if figlet is NOT installed

   # uDev: Confirmar se no futuro pode haver problemas com a font: Enviar para omni-log

   # If previously the variable $V_greet was not set by any script, then assign a <Placeholder> to it.
      [[ -z $V_greet ]] && V_greet="< V_greet >"

   # Creting an alternative message in case figlet is not installed
      V_basename=$(basename $0)
      V_2nd_option="<< $V_greet >>\n\n > Running: $V_basename\n > Missing: \`figlet\` \n"

   clear
   F_c2
   figlet $V_greet 2>/dev/null || echo -e "$V_2nd_option"
   F_rc
}

function F_Greet {
   # Same as F_greet, but for Text that uses all the ascii space like "g" in "Yoga". This fx only adds another empty line below the ascii "g"
   F_greet
   echo
}

function F_greet2 {
   # Prints a more verbose output of the ascii text "DRYa" then F_greet

   bash ${v_REPOS_CENTER}/DRYa/all/bin/drya-presentation.sh 2>/dev/null \
      || echo -e "DRYa: app available \n > (For a pretty logo, install figlet)"  # In case figlet or tput are not installed, echo only "DRYa" instead
}

# uDev: F_greet, F_Greet, F_greet2 ... change to F_g1, F_g2, F_g3 ...

function F_talk {
   # uDev: change to F_tk
   # Colorfull text to preceed any text of any important text line

   # If previously no script gave the variable $V_talk, then, assign "DRYa-lib-1" to it
      [[ -z $V_talk ]] && V_talk="< V_talk > "

   F_c2; echo -n "$V_talk"
   F_rc
}

function F_suc1 {
   # Fx number 1 of 2 
   # Use this to give confirmation the previous command has successfull
   # Use it after F_anyK fx

   # EXAMPLE: 
   #     echo "Did this message work?" && echo "Success!"
   #     echo "Did this message work?" && F_suc1 || F_suc2
   #     echo "Did this message work?" && F_suc1 || F_suc2 && exit 1

           echo -n " > "
     F_c7; echo       "Success!"
     F_rc

   # Set a variable to indicate exit status
      V_suc=0
}

function F_suc2 {
   # Fx number 2 of 2 
   # Use this to give confirmation the previous command has successfull
   # Use it after F_anyK fx

   # EXAMPLE: 
   #     echo "Did this message work?" && echo "Success!"
   #     echo "Did this message work?" && F_suc1 || F_suc2
   #     echo "Did this message work?" && F_suc1 || F_suc2 && exit 1

           echo -n " > "
     F_c8; echo       "Failed!"
     F_rc

   # Set a variable to indicate exit status
      V_suc=1
}

function F_done {
   # Use this after all precesses are finished

   F_talk; echo "Done!"
   F_rc
}

function F_anyK {
   # Press Any key to continue
   # Or wait X seconds




   # A variavel $V_txt tem de ser definida antes desta fx ser chamada
      # EXEMPLO:
      #
      # V_txt="Editado X"
      # F_anyK
      #
      # EFEITO: 
      # DRYa: Are you sure: "Editar X"
      #  > Are you sure? (Press ANY key to confirm) 



   # Set how many seconds to wait before automatically continue
      V_secs=5

   # Message
      V_msg=" ... (Continue: ANY KEY | Cancel: Ctrl-C ) "

   # Set $V_txt to " ... " in case the user forgets to set it (must be unset before this fx finishes
      [[ -z $V_txt ]] && V_txt=" ... "

   # Text to print
         #echo
   F_talk; echo -n 'Are you sure? `'
     F_c5; echo -n "$V_txt"   # A variavel $V_txt tem de ser definida antes desta fx ser chamada
     F_rc; echo '`'
           echo -n "$V_msg"
           read -sn1
     F_rc; echo -e "\r\033[K > A Continuar..."

   # Removing variables before the fx finished
      unset V_txt
}


function F_prsD {
   # Press key 'D' or 'd' to continue
   # Or wait X seconds




   # A variavel $V_txt tem de ser definida antes desta fx ser chamada
      # EXEMPLO:
      #
      # V_txt="Editado X"
      # F_prsD
      #
      # EFEITO: 
      # DRYa: Are you sure: "Editar X"
      #  > Are you sure? (Press D to confirm) 



   # Set how many seconds to wait before automatically continue
      V_secs=5

   # Message
      V_msg=" ... (Continue: 'd' or 'D' | Cancel: Ctrl-C or Any Key) "

   # Set $V_txt to " ... " in case the user forgets to set it (must be unset before this fx finishes
      [[ -z $V_txt ]] && V_txt=" ... "

   # Text to print
         #echo
   F_talk; echo -n 'Are you sure? `'
     F_c5; echo -n "$V_txt"   # A variavel $V_txt tem de ser definida antes desta fx ser chamada
     F_rc; echo '`'
           echo -n "$V_msg"
           read -sn1 V_ans
           echo
     
     [[ -n $V_ans ]] && echo -e "\r\033[K > A Continuar..."

   # Removing variables before the fx finished
      unset V_txt
}

function F_hzl {
   # Prints an horizontal line according to the amount to line existent in the current terminal
   # This fx exists also at .../init-bin/horizontal-line.sh

   # If the script that used this library does not set the variable that fills the line, then the character is set as default here
      [[ -z $V_hzl ]] && V_hzl="-"
   
   # Allowing $1 to overwrite $V_hzl
      [[ -n $1 ]] && V_hzl=$1
      
   V_cols=$(tput cols)
   printf "%*s" $V_cols | tr " " "$V_hzl"

   unset V_hzl  # Obrigar a que as fx externas tenham sempre de configurar esta variavel para que ela saia do padrao default
}

function F_horizline {
   # Criar uma linha horizontal do tamanho correto do ecra

   # Buscar tamanho correto (precisa da dependencia `tput`)
      V_cols=$(tput cols)

   # Escrever uma linha no ecra
      for i in $(seq $V_cols); do
         echo -ne "-" 
      done
}



function F_verticline {
	v_lines=$(tput lines)
	for i in $(seq $V_lines); do
   	echo -ne "   |\n" 
	done
}

#  function F_nr_test {
#     # Testa se a Var fornecida é numero ou nao
#     # V_nr
#     
#     case $V_nr in
#        1 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 0)
#           V_nr=true
#           ;;
#     esac
#  }

function db {
   # Function for fast debugging
   # use: After sourcing this drya-lib-2, just add a line `db` to it
   read -s -p " ------> Debug <------ "
   echo
}

function F_debug {
   # Creating a pause in the middle of the script for debugging process
   
   # Var to print as debug message: V_debug (do not set this var if not needed)
   echo "Debuging... $V_debug"
   echo -n " > 3"
   read -sn1
   echo -n ", 2"
   read -sn1
   echo -n ", 1... "
   read -sn1
}

function F_pin {
   # Adicionar pin aos pedidos de certas fx
   # V_pin is defined at source-all-drya-files
   # V_pin=$(grep "v_pin" ${v_REPOS_CENTER}/DRYa/all/source-all-drya-file)
   V_pin=0000

   # Se no 'main' script o user definiu texto para apresentar no ecra, entao esse texto é apresentado
      [[ -n $V_pin_txt ]] && echo "$V_pin_txt" 

   read -sp " > Introduz um PIN: " V_ans

   [[ $V_ans != $V_pin ]] && F_suc2 && exit 1
   [[ $V_ans == $V_pin ]] && F_suc1

   unset V_pin_txt

}


# {----------------------------------------------------------------------
# Material do center text (vertically, horizontally) found in source-all-drya-files
#
#  # For the lines: 
#     # Count number of lines in the terminal:
#        V_tLines=$(stty size | cut -d ' ' -f 1)
#          #echo "current number of lines in the terminal is: $V_tLines"
#
#     # Dividing that number into 2
#        V_half_tLines=$(expr $V_tLines / 2)
#         #echo "Half of that is (rounded number): $V_half_tLines"
#
#     # And the into 2
#        V_half_half_tLines=$(expr $V_half_tLines / 2)
#        V_lines=$V_half_half_tLines
#
#
#
#
#
#  # For the Columns: 
#     # Count number of lines in the terminal:
#        V_tCols=$COLUMNS
#          #echo "current number of columns in the terminal is: $V_tCols"
#
#     # Removing the number of characters from the text variables:
#        V_tCols=$(expr $V_tCols - $V_char) 
#
#     # Dividing that number into 2
#        V_half_tCols=$(expr $V_tCols / 2)
#        #echo "Half of that is (rounded number): $V_half_tCols"
#
#     V_cols=$V_half_tCols
#
#
#
#  # Center Vertically 
#     for i in $(seq 1 $V_lines)
#     do
#        # Filling a file with empty lines
#        echo -e "\n" >> $V_preMSGS
#     done
#
#  # Center Horizontally
#     echo "${v_cols}$V_msg_1" >> $V_preMSGS
#     echo "${v_cols}$V_msg_2" >> $V_preMSGS
#
# }----------------------------------------------------------------------





# -----------------------------------------------------------------------------------------
# --+-- Above: functions for '__main__' scripts                                     --+--  
# -----------------------------------------------------------------------------------------

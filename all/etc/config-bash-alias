#!bin/bash

# Title: config-bash-alias
# Description: Dv List of all alias and Functions (for Linux terminal)
# Use: This file is meant to be sourced from "~/Repositories/DRYa/all/source-all-drya-files"
# 
# Install this file
#   1. open ~/.bashrc
#   2. paste: "source ~/Repositories/DRYa/all/source-all-drya-files"

# Verbose file (variables and outputs)
   v_title="config-bash-alias"  # Name of this file
   echo "DRYa: File started loading: DRYa's $v_title" >> $v_MSGS
   echo "      > $v_title after internal software is loaded, I load the alias and extras" >> $v_MSGS


function f_cor1 { 
   tput setaf 5
}

function f_cor2 { 
   tput setaf 6 
}
function f_cor3 { 
   tput setaf 8 
}
function f_resetCor { 
   tput sgr0 
}


# Set the keybindings to vi/vim mode:
   #set -o vi

function E {
   select i in Nano Vim; do 
      case $i in 
         Nano)
	         if [ $i == "1" ]; then alias r="nano"; fi
         ;;
         Vim)
            if [ $i == "2" ]; then alias r="vim"; fi
         ;;
         *)
            echo lol
         ;;
      esac
   done
	
}

# DRYa-termux-omni-key (Bash keyboard bindings)
   # Bind F7 keycode: "\e[18~"
     v_default_omni_key="ॐ"
   
      # To print "Hi!" (just print)
         #bind '"\e[18~":"Hi!"'

      # To exec 'man cat' 
         #bind -x '"\e[18~":"man cat"'

      # To exec 'upk' 
         function f-set-omni-key-upk {
            cp ${v_REPOS_CENTER}/DRYa/all/etc/dot-files/termux/termux.properties ~/.termux
            sed -i "s/ॐ/⍾/g" ~/.termux/termux.properties
            bind -x '"\e[18~":"upk"'
            termux-reload-settings
         }

      # To open/exec the Android App: "Leitor QR"
         function f-set-omni-key-qr {
            cp ${v_REPOS_CENTER}/DRYa/all/etc/dot-files/termux/termux.properties ~/.termux
            sed -i "s/ॐ/⎆/g" ~/.termux/termux.properties
            bind -x '"\e[18~":"am start --user 0 -a andrppoid.intent.action.MAIN -n com.teacapps.barcodescanner/net.qrbot.ui.main.MainActivity"'
            termux-reload-settings
         }
      
      #bind -x '"\e[18~":"f-set-omni-key-qr"'

      # Reset omni-key {
         function f-reset-omni-key {
            cp ${v_REPOS_CENTER}/DRYa/all/etc/dot-files/termux/termux.properties ~/.termux
            #sed -i "s/⎆/ॐ/g" ~/.termux/termux.properties  ## Se o ficheiro em .../etc/dot-files/... for copiado diretamente para ~/.termux/termux.properties entao nao é preciso 'sed'
            termux-reload-settings
            bind -x '"\e[18~":"F"'

         }
         f-reset-omni-key

function key {
   # Menu para alternar drya-termux-omni-key icon e funcionalidade
   figlet Omni Key
   echo "Opcoes:"
   echo " > om"
   echo " > upk"
   echo " > qr"

   read -p "Qual a funcao que quer para omni-key? " v_ans

   if [ $v_ans == "om" ]; then f-reset-omni-key
   elif [ $v_ans == "qr" ]; then f-set-omni-key-qr
   elif [ $v_ans == "upk" ]; then f-set-omni-key-upk
   fi

}

function siigo {
   # Using termux 
      function f_termux_siigo {
         termux-open-url https://siigo-maintenance.com/#/calendar
      }
      
   # Using chrome   
      function f_chrome_siigo {
         "/mnt/c/Program Files/Google/Chrome/Application/chrome.exe" https://siigo-maintenance.com/#/calendar
      }

   # Calling siigo webpage using one of the above options:
      f_chrome_siigo || f_termux_siigo
      
}


# Telling bash not to save command line on history log file that have either a whit space befor it ou that the previous line is duplicate
   # More info at: '$ man bash'
   HISTCONTROL=ignoreboth

alias appdata="udev: must be completed"

# Termux alias
   alias rec="termux-microphone-record -d; clear" # Starts voice recording (There should be a fast dial for this option)
   alias a="termux-microphone-record -d" # Starts voice recording (There should be a fast dial for this option)
   alias b="termux-microphone-record -q" # Stops voice recording (There should be a fast dial for this option)
   alias cer="termux-microphone-record -q" # Stops voice recording (There should be a fast dial for this option)
   alias recs="termux-microphone-record -q" # Stops voice recording (There should be a fast dial for this option)
   alias paste="termux-clipboard-get"
   alias sms="termux-sms-send -n" 
   alias REC="termux-microphone-record -l 0"

# Termux sms script
   function sms {
      case $1 in
         send)
            v_1="-n $2"
            v_2=$3
            echo "termux-sms-.. $v_1 $v_2" 
         ;;
         in)
         ;;
         out)
         ;;
         *)
         ;;
      esac
}


alias grep="grep --color=auto"

function bt {
   # See battery status
   
   if [ $(uname -o) == "Android" ]; then
      termux-battery-status
   else
      case $1 in 
         -a) upower -i `upower -e | grep 'BAT'` ;;
         -p) echo -n "Battery percentage = " && cat /sys/class/power_supply/BAT0/capacity ;;
         *) upower -i $(upower -e | grep BAT) | grep --color=never -E "state|to\ full|to\ empty|percentage" 
         ;;
      esac
   fi
}


alias irc="irssi" # An IRC client :: Install it with: pkg install irssi

function f_debug {
   # Degug function: use it when you need to re-open this file over and over again for debug.
	read
	vim ${v_REPOS_CENTER}/DRYa/all/config-bash-alias
	#pkill -9 -x ~/Repositories/DRYa/all/config-bash-alias
}

function f_drya-messages {
   # All Seiva's software (including DRYa)
      # will have at the start of the file,
      # a line that
      # will tell ~/.tmp/drya-messages.txt
      # that that specific file was read.
      # This is for debugging process.
      # You can add a line to ~/.bashrc to delete
      # ~/.tmp/ everytime you open the terminal
      # and that way, everything is refreshed everytime

      alias drya-messages="less ~/.tmp/drya-messages.txt" #uDev: change to .dryarc  ## uDev: to be sent to drya.sh
}

# joke:
   alias research="tree /;tree /;tree /;tree /;tree /;tree /;tree /;tree /;tree /;tree /;tree /;tree /;tree /";

alias ls="ls -p"
alias la="ls -pA"
alias ll="ls -pl"
#alias lll= pwd + file paths (uDev)
alias mk="mkdir" # Creates one directory for each name given as an argument and in case that succeeds, changes working directory for the directory given as the first argument
alias d="cd"
alias dcim='cd ~/storage/dcim/Camera || echo " \> You are trying to navige to a dir usually present on Android using Termux"'

# Media tools:
   alias miau="termux-open-url https://www.instagram.com/reel/CinlDmBO0tO/?igshid=YmMyMTA2M2Y="
   alias preta="termux-open-url https://www.instagram.com/reel/Cnol075KSIU/?igshid=YmMyMTA2M2Y="
   alias vibrato="termux-open-url https://www.youtube.com/watch?v=OLfwxzY-l7o"

function op {
   # Function to open all files and directories given as arguments ($*)
      # Similar apps: termux-open; termux-open-url; wslview

   # uDev: Since DRYa is developing drya-neofetch, then in the future we will get our OS from an environment variable made by DRYa

   # Test in which OS this script is running:
      v_uname=$(uname -a)

   # Try to find the file opener at each OS:
      if [[ $v_uname =~ "Microsoft" ]]; then 
         # Test if this script is a Linux OS running inside windows (WSL (Windows sub-system for Linux):
            /mnt/c/windows/explorer.exe $*

      elif [[ $v_uname =~ "Android" ]]; then
         # If it finds "Android" then it should be working at Termux terminal
            xdg-open $*

      elif [[ $v_uname =~ "Linux" ]]; then
         # If it is Any kind of Linux, try to open as standard
            xdg-open $*
      else
         echo "DRYa: op: Attempt to open that argument failed"
      fi
      
      # uDev: Add 'termux-open $* --chooser' as an option
}


# Ask the terminal to print the stroken
   alias stroken="cat ${v_REPOS_CENTER}/DRYa/all/etc/dot-files/git-github/current-stroken"
   # Notes:
      # At ${v_REPOS_CENTER}/DRYa/all/install.uninstall/stroken there is a copy of this file but with kore info to help new app users
      # We can install stroken automatically with: '$ drya install stroken'

# Fast dial:
   # uDev: for WSL2, shutdown and reboot must be done by batch scripts
   alias 2468="exit"
   alias 24685="shutdown now"
   alias 246854="shutdown -r now"
   alias 48256="termux-microphone-record -d 1>/dev/null" # Starts voice recording without any terminal output
   alias "48256."="termux-microphone-record -q 1>/dev/null" # Stops voice recording without any terminal output
   alias 453="upk"
   alias reboot="shutdown -r now"

# uDev: alias web="open default browser"
alias website="termux-open-url https://seiva.yolasite.com/ 2>/dev/null || op https://seiva.yolasite.com/"


alias play="termux-media-player play"
alias pause="termux-media-player pause"
alias stop="termux-media-player stop"
alias info="termux-media-player info"
alias sound="termux-media-player play ${v_REPOS_CENTER}/DRYa/all/etc/example-sound.wav" ## example sound

alias tufnar="echo '# uDev: Tufnar Isaura 91... Check a phone list on omni-log" 


function shebang {
   # It creates a bash script (if no args are input)
      # Or gives a shebang to the file you input as argument 1)
      # It also changes the permissions of tbe file to executable

   function f_inform_creation_noArgs {
      # Informing the user that the process is ready
      
      # Using command 'ls' to test existence
         ls $v_ans 1>/dev/null # Delete all output
         if [[ $? == 0 ]]; then # If last '$ ls' command was sucessfull, then:

            tput setaf 3
               echo -n " > File "
            tput setaf 4
               echo -n $v_ans
            tput setaf 3
               echo " created!"
            tput sgr0

            read -s -n 1
            vim $v_ans
         else 
            echo File not created
         fi
   }

   function f_inform_creation {
      # Informing the user that the process is ready

      
      # Using command 'ls' to test existence
         ls $i 1>/dev/null # Delete all output
         if [[ $? == 0 ]]; then

            tput setaf 3
               echo -n " > File "
            tput setaf 4
               echo -n $i
            tput setaf 3
               echo " created!"
            tput sgr0
         else 
            echo File not created
         fi
   }

   function f_test_existence_noArgs {
      # Test existence of file named as argument given

      if [[ -f $v_ans ]]; then
         # Test if file exists to avoid overwriting it
         echo -n "File "
         tput setaf 4
         echo -n "$v_ans "
         tput sgr0
         echo "already exists, please choose another name"
      else 
         # If file does not exist, run:
         touch $v_ans
         echo "#!/bin/bash" > ./${v_ans}
         chmod +x ./${v_ans}

         f_inform_creation_noArgs
         vim $v_ans

      fi
   }

   function f_test_existence {
      # Test existence of file named as argument given

      if [[ -f $i ]]; then
         # Test if file exists to avoid overwriting it
         echo -n "File "
         tput setaf 4
         echo -n "$i "
         tput sgr0
         echo "already exists, please choose another name"
      else 
         # If file does not exist, run:
         touch $i
         echo "#!/bin/bash" > ./${i}
         chmod +x ./${i}
         
         f_inform_creation 

      fi
   }

   if [[ -z $1 ]]; then
      # If no arg is given
         echo -n " > File name? "
         read v_ans

         f_test_existence_noArgs

   else 
      # If there are arguments, test each one for exuatence:
         for i in $@; do 
            f_test_existence
         done
   fi
}


function go {
	# This function opens applications apart from the terminal. It means that you can close the terminal after the aplications launch and the terminal being killed does not kill the apps it created
	for v_arg in $@
	do
		setsid $v_arg &>/dev/null
	done

      # Detecting if any of the arguments given has the word "terminal" to replace for "gnome-terminal"
      if [[ $@ =~ "terminal" ]]; then setsid gnome-terminal &>/dev/null; fi


      # Detect if LAST argument is "bye" to make the current terminal "exit"
         # Store all arguments inside a variable
         v_allArguments=$*
         
         # Using awk to detect only the last argument
         v_lastArg=$(echo $v_allArguments | awk '{ print $NF }')
         if [ ${v_lastArg} == "bye" ]; then 
            #echo "bye was said. Press enter to exit"    #Exit message
            #read                                        #Pause before exit
            exit
         fi

      # If there is an app called "bye" that you want to open with the command "go" then just put something else in from of it to prevent "exit" command to happen
         # Use: $ go bye ...

      # If you simply want to restart the terminal
         if [ $1 == "again" ]; then gnome-terminal && exit; fi

   # If you want to export just this "go" script for an entire repository, the name sugested is: bash-open-app-at-external-window
}

# This command is same as: "source ~/.bashrc" (but needs the function: go)
alias src="go gnome-terminal; exit"


function . {
   # Navigate through the file system stupidly ez
   
   # uDev: Include 'function d' to give 'favs' if directory is not found

      if [ -z $1 ]; then 
         # If no argument is given, lists storage (ls command)
         ls 

      elif [ $1 == "." ]; then 
         # If arg 1 is '.' then navigate to the center of seiva's repos
         cd $v_REPOS_CENTER
         # uDev: this command '. .' is usually issued at thr beggining of the day when the user is going to start the coding session. Therefore: Echo once a day to REMEMBER to git pull
   
      elif [ $1 == "?" ]; then 
         # Describe all these navigation alias
         echo "'. ?' Shows this help menu" 
         echo ".  1x Means: ls"
         echo "..  2x Means: cd .."
         echo "...  3x Means: cd -"
         echo "....  4x Means: pwd"
         echo ".....  5x Means: save this dir location in var \$h"
         echo "......  6x Means: save previous dir location in var \$v"
         echo ".......  7x Means: remember last 2 variables set as \$h and \$v"

      elif [ ! -z $1 ]; then
         # If argument is given and it is a dir, cd into it, otherwise if it a file, edit it
         cd $1 || vim $1
      fi
}

#alias .="ls"  ## Replaced by the 'function . { }' and the 'function D { }'
alias ..="cd .."
alias ...="cd -"

function .... {
   echo 'Current location $(pwd)'
   echo " > $(pwd)"
}

function ..... {
   # Saves current directory location 
   # uDev: If script npNP gets finished, this one function gets useless. Finish that
   h=$(pwd)
   echo 'Current location $(pwd) saved as variable $h'
   echo " > $(pwd)"
}
function ...... {
   # This function is usefull when you want to move files to the previous directory
      # 1 - Move to the destination you want to past the files
      # 2 - Move to the origin of the files in one command using absolute path (where they are currently)
      # 3 - press: .....
      # Use command: mv <file1> <file2> <file3> $v
   # uDev: If script npNP gets finished, this one function gets useless. Finish that
   cd -   1>/dev/null   
   v=$(pwd)
   cd -   1>/dev/null   
   echo 'Last directory $(pwd) saved as variable: $v'
   echo " > $v"
}
function ....... {

   echo 'Variable $h saved as:'
   echo " > $h"
   echo
   echo 'Variable $v saved as:'
   echo " > $v"
}
alias ,="cd"
alias ,,="clear; tput cnorm" # Also resets the blinking cursor if it was hidden
alias ,,,=", ; ,," # Same as both 2 previous commands put together
alias .,="ls -Ap" # uDev: This is meant also to SEE if the directory is empty or not, therefore, if the dir is Totally empty, echo "This place is empty"
alias CLEAR="cd; clear; figlet 'Clear'; tput cnorm" # Also resets the blinking cursor if it was hidden

function f_emacs {
   # Attempt to untangle emacs alias (due to so many versions)
   
   alias em="emacs"
   alias Em="/mnt/c/Program\ Files/Emacs/x86_64/bin/emacs.exe" # Opens emacs GUI on windows OS
   alias Emacs="/mnt/c/Program\ Files/Emacs/x86_64/bin/emacs.exe" # Opens emacs GUI on windows OS

   # Decide for alias EM which emacs corresponds best with the System
      if [ -f /mnt/c/Program\ Files/Emacs/x86_64/bin/emacs.exe ]; then 
         # If emacs GUI exists (on windows), then
         alias EM="/mnt/c/Program\ Files/Emacs/x86_64/bin/emacs.exe" 

      else 
         ## If emacs GUI does not exist, then set it for terminal emacs
         alias EM="emacs"
      fi
}
f_emacs

alias a="cd all && ls"
alias hi="hello!"

# uDev: to put under menuFAV F
alias hind="vim ${v_REPOS_CENTER}/yogaBashApp/all/about-hinduism/about-hinduism.txt"


# Pandoc app to create man pages

function npNP-dir-looper {
   # Title: next-previous-Negative-Positive
   # (looper app) Save a loop of directories:
      alias P="Positive dir"  #uDev: Adds current dir to loop
      alias N="Negative dir"  #uDev: Removes current dir from loop
      alias p="previous dir"  #uDev: Swap to previous dir present in the loop 
      alias n="next dir"      #uDev: Swap to next dir present in the loop
      alias PP="list all stored locations as other apps list buffers"
      alias NN="Prompt the user if he wants to delete the entire list of locations"
      # when adding arguments:
         # Using a number as an argument like: '$ np 1' makes you travel the the location listed first
         # Using - or + to swap priority of the location listed in the list (example: '$ np +' and '$ np -)

      # np | pn | Np | Pn) list all dirs and current one
      function P {
         mkdir -p ~/.config/h.h/nPpN-dir-looper
         pwd >> ~/.config/h.h/nPpN-dir-looper/nPpN-list.txt
          
      }

      # Curiosity: by typing '$ man termux' you can see that by coincidence and also by luck, termux uses the volume key <Up> to perform control over the terminal and over the smartphone.
         # Two of those Volume Up shorcut control are:
         # 'Volume key Up + P': Page Up
         # 'Volume key Up + N': Page Down
         # To make it even better, remember that the command ZZ in Vim, puts the current line at the middle of the screen.
            # These 3 commands allow you to see before, after and around your current line in the current file
}  ## end of function: npNP-dir-looper
#npNP-dir-looper

alias R='echo "List Repositories by number and jumpt to them. uDev: Not available yet"'

# Acessing emacs-wiki.org
alias emacs-wiki="emacs ${v_REPOS_CENTER}/dWiki/emacs/gnu-emacs/emacs-wiki.org" #Add message "file: ~/Repos.../x.../y.../z... was opened" >> ~/.tmp/messages.txt

# Acessing emacs init.el file
   alias emacs-init="emacs ~/.emacs.d/init.el"

# Using Num Pad numbers as shortcuts
   function win-hibernate {
      cd ${v_REPOS_CENTER}/DRYa/all/batch/shut-restart-hibernate-sleep/ && \
      /mnt/c/Windows/System32/cmd.exe /c hibernar.lnk
   }

   alias exe="/mnt/c/Windows/System32/cmd.exe /c"
   alias 2468="exit"
   alias 24685="shutdown now"
   alias 246854="shutdown -r now"
   alias 246856="win-hibernate"



alias bashrc="vim ~/.bashrc"
alias vimrc="vim ~/.vimrc"

function f_notes {
   echo "uDev: Will handle user notes and anotations in the future"
   echo "alias << 1 >> set to:"
   echo " > omni-log" && alias 1="echo uDev: will be omni-log"
}

# history-recall app
	function hist {
		mkdir -p ~/.tmp/
		history > ~/.tmp/fileA.txt
		history

		echo -e "\n > Type Ctrl+C to cancel \n > Type a number to navigate: "
		echo -n " > "
		read v_ans

		#echo "grep results:"

		grep "$v_ans" ~/.tmp/fileA.txt > ~/.tmp/fileB.txt

		# Remove 2 character to the begining of the text
		sed -i 's/^..//g' ~/.tmp/fileB.txt

		# Debugging process
		#echo "Sed results:"
		#echo "cat fileB"
		#cat ~/.tmp/fileB.txt

		# Search patter of the beggining of the line
		grep ^$v_ans ~/.tmp/fileB.txt > ~/.tmp/fileA.txt

		# Debugging process
		#echo "cat fileA"
		#cat ~/.tmp/fileA.txt
		sed -i 's/^\w*\ *//' ~/.tmp/fileA.txt

		# Now, cutting the command
		cut -d ' ' -f2- ~/.tmp/fileA.txt
		
		# Debugging process
		#echo "fileA after cut"
		#cat ~/.tmp/fileA.txt
		#echo "trying to eval:"
		#read

		# Creating a variable called v_eval to store the content of the file as text
		v_eval=$(cat ~/.tmp/fileA.txt)

		# Trying to run the text of the file. If it the shell has executables that are called the same way as this txt is written, then run this text at the terminal as if it was written to trigger an executable
		eval $v_eval
	}

# Alias morse-code-style
   # Dot="morse ."
   # Dash="morse ,"
   # word="morse ..., ,.., .,,"

# To load upk Repo at .bashrc with .dryarc:
   #cat upk.sh then search only for a function of greetings, then echo that out

#     function drya {
#        if [ -z $1 ];
#           # If drya is called with no arguments: 
#           then 
#              echo "no args"
#              bash ~/Repositories/DRYa/drya.sh
#        elif [ $1 == "catMe-dryarc" ];
#           # If terminal: "$ drya catMe-dryarc":
#           then
#              echo "arg: catMe-dryarc"
#              cat ~/.config/h.h/.dryarc
#        else
#           echo "need something?"
#        fi
#     }
#     
#     alias drya-editMe-permanently="vim ${v_REPOS_CENTER}/DRYa/all/config-bash-alias"
#     alias drya-editMe-temporarily="vim ${v_REPOS_CENTER}/DRYa/install.uninstall/drya.installer/future-dryarc"
#     #alias drya-updateMe-locally="cat ~/.config/h.h/.dryarc >> ${v_REPOS_CENTER}/DRYa/all/config-bash-alias && rm ~/.config/h.h/drya/.dryarc && creat .dryarc(with contents)" # This line copies temporary settings from users of drya and appends it to the directory where drya is installed and running. This way, if you push it to github, it will be permanent
#     alias drya-updateMe-globally="echo 'ezGIT must be installed'"
#     #alias drya-make-dryarc # uDev: function exists inside drya.sh


alias sourceAll="source ~/.bashrc"

# function drya {
#   PS3="Select the operation: "
#   select opt in Configurations installations edit-files quit
#   do
#      case $opt in
#         Configurations)
#            read -p "Enter the first number: " n1
#            read -p "Enter the second number: " n2
#            echo "$n1 + $n2 = $(($n1+$n2))"
#            ;;
#         installations)
#            read -p "Enter the first number: " n1
#            read -p "Enter the second number: " n2
#            echo "$n1 - $n2 = $(($n1-$n2))"
#            ;;
#         edit-files)
#            read -p "Enter the first number: " n1
#            read -p "Enter the second number: " n2
#            echo "$n1 * $n2 = $(($n1*$n2))"
#            ;;
#         quit)
#            break
#            ;;
#         *)
#            echo "Invalid option $REPLY"
#            ;;
#      esac
#      # It works as a while loop too
#   done
#}



function hkllhcf {
   # If if you invoke "cdl" and no dir exists
   if [ ! -d "./$1" ]; then
      
      # A function that is needed to be prepared in case later on the code it is called:
      function f_cdl_mkdir {
         # Generate a random number to be used as a key to delete our previous directory if it was  reated by mistake
         declare v_random=$RANDOM

         # If a new directory is to be created, verbose descriptions will happen
         echo -n " > That directory "
         tput setaf 4
         echo -n $1
         tput sgr0
         echo " was not existent"
         echo "  > Therefore was created"
         echo -n "  > Delete it by executing "
         tput setaf 4
         echo $v_random
         tput sgr0
      }

      declare cur_dir=$1
      mkdir -p $1 
      f_cdl_mkdir
      cd $1
      ls

   else
      # If you invoke "cdl" and dir exists
      cd $1
      ls
      echo "normal run"
   fi
alias v="echo sk"
}

# '$ drya populate main-apps'
  # Source all other repos if they exist:
  # Source jarve
  # Source upK
  # Source ezGIT
  # Source ... 
  

function drya-test {
   PS3="Select the operation: "
   select opt in Configurations installations edit-files quit
   do
      case $opt in
         Configurations)
            read -p "Enter the first number: " n1
            read -p "Enter the second number: " n2
            echo "$n1 + $n2 = $(($n1+$n2))"
            ;;
         installations)
            read -p "Enter the first number: " n1
            read -p "Enter the second number: " n2
            echo "$n1 - $n2 = $(($n1-$n2))"
            ;;
         edit-files)
            read -p "Enter the first number: " n1
            read -p "Enter the second number: " n2
            echo "$n1 * $n2 = $(($n1*$n2))"
            ;;
         quit)
            break
            ;;
         *)
            echo "Invalid option $REPLY"
            ;;
      esac
      # It works as a while loop too
   done
}

alias eoc="echo 'end of chapter, right?'; echo >> ~/eof; info 1>>~/eoc"

# Bash fork bomb
   # Link tutorial: https://youtu.be/wIsGXkxXZzE
   alias fork-bomb=":() { :|: & };:"

# Verbose file (variables and outputs)
   echo "DRYa: File ended loading: DRYa's $v_title" >> $v_MSGS

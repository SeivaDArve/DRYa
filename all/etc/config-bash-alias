#!bin/bash

# Title: config-bash-alias
# Description: Dv List of all alias and Functions (for Linux terminal)
# Use: This file is meant to be sourced from "~/Repositories/DRYa/all/source-all-drya-files"
# 
# Install this file
#   1. open ~/.bashrc
#   2. paste: "source ~/Repositories/DRYa/all/source-all-drya-files"

# Verbose file (variables and outputs)
   v_title="config-bash-alias"  # Name of this file
   echo "DRYa: File started loading: DRYa's $v_title" >> $v_MSGS
   echo "      > $v_title after internal software is loaded, I load the alias and extras" >> $v_MSGS


function f_cor1 { 
   tput setaf 5
}

function f_cor2 { 
   tput setaf 6 
}
function f_cor3 { 
   tput setaf 8 
}
function f_resetCor { 
   tput sgr0 
}


# Set the keybindings to vi/vim mode:
   #set -o vi

function E {

   PS3="SELECT a file editor to set as default"

   select i in Nano Vim Emacs; do 
      case $i in 
         Nano)
	         if [ $i == "1" ]; then alias e="nano"; fi
         ;;
         Vim)
            if [ $i == "2" ]; then alias e="vim"; fi
         ;;
         Emacs)
            if [ $i == "3" ]; then alias e="emacs"; fi
         ;;
         *)
            # uDev: permitir escolher outro, definindo o seu nome numa variavel $v_editor e depois usando com o comando `eval $v_editor <ficheiro>`
            echo lol
         ;;
      esac
   done
	
}

# uDev: fx para verificar se existem novos bookmark no browser

alias foto="am start -a android.media.action.IMAGE_CAPTURE"

alias start-termux-gui="vncserver -localhost :1"  # Inicia o servidor VNC no ecra :1
alias stop-termux-gui="vncserver -kill :1"  # Inicia o servidor VNC no ecra :1

alias note="uDev: Create a note file with Date as a title"

alias timg="termimage"

alias notas="bash /home/indratena/Repositories/scratch-paper/shuf"  # temporary alias

function f_fzf_raw_link_opener {
   # Esta fx visita a repo 'Omni-log' e usa o script lá presente com menu `fzf` que filtra os links dos ultimos backups de bookmarks.. O link de lá escolhido, será usado aqui

   # Navegar para a pasta que contem o backup de bookmarks e também o script que filtra esses bookmarks
      cd ${v_REPOS_CENTER}/omni-log/all/browser-bookmarks/
      bash ${v_REPOS_CENTER}/omni-log/all/browser-bookmarks/raw-link-opener.sh
      cd -
   
   # Como o script anterior já vai abrir o link que encontrar no browser, entao neste script informamos às proximas fx que nao haverá URL  
}

function web {
   # dee: T: `web`  ::  D: Fx que abre websites corretamente de acordo com o dispositivo/maquina atual  #HashTag:987657897
   # Simply opening a browser (args may be given)
   # Note: after this fx, some shortcuts will be created also
   
   # uDev: Usar metodo de desconectar o precesso por completo do terminal atual
   # uDev: Filtrar os "browser-bookmarks" e fornecer uma opcao para isso

   # Homepage pre-definida
      homePage="https://duckduckgo.com"
      #homeName="Duck Duck Go"

   # Reset à variavel
      unset v_URL

   # Identificar os argumentos que se enviam para esta fx
      if [ -z $1 ]; then 
         # Se nao for dado nenhum argumento, dar a oportunidade ao utilizador de escolher entre a homepage e uma lista de bookmarks
   
         v_ask=$(echo -e "1. Abrir $homePage \n2. Abrir Bookmarks Guardados" | fzf --prompt="SELECT: como quer aceder à Web: ")

         [[ $v_ask =~ "2" ]] && f_fzf_raw_link_opener 
         [[ $v_ask =~ "1" ]] && v_URL="https://duckduckgo.com"
         
      elif [ $1 == "siigo" ]; then 
         v_URL="https://siigo-maintenance.com/#/calendar"

      elif [ $1 == "gpt" ]; then 
         v_URL="https://chatgpt.com/?oai-dm=1"

      elif [ $1 == "duck" ]; then 
         v_URL="https://duckduckgo.com"
         
      elif [ $1 == "lojas" ]; then 
         v_URL="https://www.cascaishopping.pt/mapa/#/location/639a8d573b88061336d69a59"

      elif [ $1 == "yt" ]; then 
         v_URL="https://www.youtube.com"

      elif [ $1 == "bm" ]; then 
         f_fzf_raw_link_opener

      else
         echo "DRYa: web: Tem de inserir um link valido"
         #echo " > Vamos tentar abrir o texto introduzido "
         #v_URL=$1

      fi

   # Send file 'nohup.out' to a tmp dir
      mkdir -p ~/.tmp


   # Identificar a maquina atual
      if [[ -z $v_URL ]]; then
         echo "Link Aberto pelo script: raw-link-opener.sh" 1>/dev/null

      elif [[ $traits_OS == "Android" ]]; then     # When using Termux
         echo "DRYa: A abrir com Termux: "
         echo " > $v_URL"

         cd ~/.tmp

         #termux-open-url "$v_URL" &
         nohup termux-open-url "$v_URL" & disown
         cd -
      
      elif [[ $traits_OS == "Linux" ]]; then      # When using Linux 
         echo "DRYa: A abrir com Linux: $v_URL"
         xdg-open $v_URL & 

      elif [[ $traits_OS == "Windows" ]]; then    # Maybe using windows 
         echo "DRYa: A abrir com Windows: $v_URL"
         "/mnt/c/Program Files/Google/Chrome/Application/chrome.exe" "$v_URL" &

      else
         echo "DRYa: Erro a abrir o link"
      
      fi

      
}

# Shortcuts for fx `web`
   # dee: HashTag:987657897
   alias siigo="eval web siigo"
   alias gpt="eval web gpt"
   alias lojas="eval web lojas"
   alias yt="eval web yt"




alias cm="cmatrix"

# Telling bash not to save command line on history log file that have either a whit space befor it ou that the previous line is duplicate
   # More info at: '$ man bash'
   HISTCONTROL=ignoreboth


# Termux alias
   alias REC="termux-microphone-record -l 0"
   alias rec="termux-microphone-record -d && clear && echo 'Going'" # Starts voice recording (There should be a fast dial for this option)
      alias a="termux-microphone-record -d" # Starts voice recording (There should be a fast dial for this option)

   alias cer="termux-microphone-record -q" # Stops voice recording (There should be a fast dial for this option)
      alias b="termux-microphone-record -q" # Stops voice recording (There should be a fast dial for this option)
      alias recs="termux-microphone-record -q" # Stops voice recording (There should be a fast dial for this option)
      
   alias paste="termux-clipboard-get"
   alias sms="termux-sms-send -n" 

# Termux sms script
   function sms {
      case $1 in
         send)
            v_1="-n $2"
            v_2=$3
            echo "termux-sms-.. $v_1 $v_2" 
         ;;
         in)
         ;;
         out)
         ;;
         *)
         ;;
      esac
}

# uDev: alias para: 'date' que neste momento so da as horas e dia em ingles e com pouca info, udev: criar date que da info tao boas quanto a fx 'date' que criei no emacs init.el

alias pycharm="pycharm-community 1>/dev/null &"

alias grep="grep --color=auto"

function bt {
   # See battery status
   
   if [ $(uname -o) == "Android" ]; then
      termux-battery-status
   else
      case $1 in 
         -a) upower -i `upower -e | grep 'BAT'` ;;
         -p) echo -n "Battery percentage = " && cat /sys/class/power_supply/BAT0/capacity ;;
         *) upower -i $(upower -e | grep BAT) | grep --color=never -E "state|to\ full|to\ empty|percentage" 
         ;;
      esac
   fi
}

function dos-2-unix {
   clear
   figlet "DRYa: DOS to Unix"
   echo "DRYa: convert a DOS file into Unix"

   ## When editing a file with emacs, it got windows new-line formatation \r and vim was not detecting it. So, when running the file that was actually a .sh script it gave the error "bash line 2: $'\r': command not found" Now, we can either run the command "sed -i 's/\r$//' scriptname.sh" or we can install dos2unix and run "dos2unix scriptname.sh". DRYa will hava a script to correct it also called 'dos-2-unix' by the reason I want to know what is being done by all my scripts

   # uDev: Adicionar explicaco disto tambem na wikiD

   echo 
   echo "It will remove a bug when bash attempts to source a file"
   echo "error message: (uDev)"
   echo "explanation: (uDev)"
   echo 
   echo "Feed me a name (or path name) of a file to correct"
   echo " > (uDev)"
   #"sed -i 's/\r$//' scriptname.sh"
}
   

alias irc="irssi" # An IRC client :: Install it with: pkg install irssi

function data {
   # Exemplo: "Data atual: (Dia 07 Sex)(Mês 06 jun)(Ano 2024)(03:38:38)"
   # uDev: fx para print apenas 1x sem loop

   while true
   do
      
      # Instrucoes:
         # echo -ne "\r"      ## Move o cursor para o inicio da linha
         # echo -ne "\033[K"  ## Sequência de escape ANSI para limpar do cursor até o fim da linha.

      v_texto="Data atual: (Dia"
      v_dia=$(date +'%d %a')
      v_texto_dia="$v_texto $v_dia"

      v_texto="$v_texto_dia)(Mês"
      v_mes=$(date +'%m %b')
      v_texto_mes="$v_texto $v_mes"

      v_texto="$v_texto_mes)(Ano"
      v_ano=$(date +'%Y)')
      v_texto_ano="$v_texto $v_ano"

      v_hora=$(date +'(%H:%M:%S)')
      v_data="$v_texto_ano$v_hora"
      echo -ne "\r\033[K$v_data "
      sleep 1

   done
}

function hora {
   # Exemplo: "Data/Hora: 2024-06-07 04:21:26"
   # uDev: fx para print apenas 1x sem loop
   while true
   do
      
      # Instrucoes:
         # echo -ne "\r"      ## Move o cursor para o inicio da linha
         # echo -ne "\033[K"  ## Sequência de escape ANSI para limpar do cursor até o fim da linha.

      v_data=$(date +'%Y-%m-%d %H:%M:%S')
      echo -ne "\r\033[KData/Hora: $v_data "
      sleep 1

   done
      
}


#alias wiki="EM ${v_REPOS_CENTER}/wikiD/wikiD"
alias wiki="EM -nw /mnt/c/wsl-dv/Repositories/wikiD/wikiD.org"

function f_debug {
   # Degug function: use it when you need to re-open this file over and over again for debug.
	read
	vim ${v_REPOS_CENTER}/DRYa/all/config-bash-alias
	#pkill -9 -x ~/Repositories/DRYa/all/config-bash-alias
}





function f_drya-messages {
   # All Seiva's software (including DRYa)
      # will have at the start of the file,
      # a line that
      # will tell ~/.tmp/drya-messages.txt
      # that that specific file was read.
      # This is for debugging process.
      # You can add a line to ~/.bashrc to delete
      # ~/.tmp/ everytime you open the terminal
      # and that way, everything is refreshed everytime

      alias drya-messages="less ~/.tmp/drya-messages.txt" #uDev: change to .dryarc  ## uDev: to be sent to drya.sh
}

# joke:
   alias research="tree /;tree /;tree /;tree /;tree /;tree /;tree /;tree /;tree /;tree /;tree /;tree /;tree /";

alias ls="ls -p --color=auto"
alias la="ls -pA"
alias ll="ls -pl"
alias lh="du -ah" # Lists all file's size
alias mk="mkdir" # Creates one directory for each name given as an argument and in case that succeeds, changes working directory for the directory given as the first argument
alias d="cd"
alias dcim='cd ~/storage/dcim/Camera || echo " \> You are trying to navige to a dir usually present on Android using Termux"'

function lll {
   echo "Printing absolute path for each file:"

   for i in $(ls -A -p);
   do
      v_pwd=$(pwd)
      v_ls="$v_pwd/$i"
      echo $v_ls
   done
}

alias tc="touch"
alias vb="cd ${v_REPOS_CENTER}/verbose-lines && echo 'Verbose-lines: tree' && tree ."

# uDev: 'Mv' Alias for 'cut' 'paste' 'list mv-v clipboard'
   # alias 'Mv'  : without arguments, show mv-cut/mv-paste clipboard and help
   # alias 'Mv c': move-cut  # add files and their absolute path to an array.... then paste then with mv-p at the dir you want
   # alias 'Mv C': move-cut  # move files from current dir to another at ~/.config/h.h/... and when 'Mv p' is used.... all contents from such dir are moved again to the final location
   # alias 'Mv p': move-paste
   # alias 'Mv l': Move to 'lixo'/'lx'
   alias lixo="mkdir -p ~/trash/ && mv $* ~/trash/"
      alias lx="lixo"

# 'Calc' and 'bc' are 2 Bash calculators
# 'split -n 5' is a command that splits a text file into 5 parts

# Media tools:
   alias untangle="termux-open-url https://youtube.com/shorts/0wobqw589l0?si=h4D_6LNBeid77Bq_"
   alias miau="termux-open-url https://www.instagram.com/reel/CinlDmBO0tO/?igshid=YmMyMTA2M2Y="
   alias capitain="termux-open-url https://youtube.com/shorts/lquMb_8j38w?si=awBQ0gxdoQYxW8TJ"
   alias eclipse="termux-open-url https://youtube.com/shorts/X87ZTOhkbf0?si=cKQGVXz4bZWySIXx"
   alias miau2="termux-open-url https://www.instagram.com/reel/C22n2C3iB_-/?igsh=MWM0bjlxN3E2aG5sNQ=="
   alias preta="termux-open-url https://www.instagram.com/reel/Cnol075KSIU/?igshid=YmMyMTA2M2Y="
   alias vibrato="termux-open-url https://www.youtube.com/watch?v=OLfwxzY-l7o"


function op {
   # Function to open all files and directories given as arguments ($*)
      # Similar apps: termux-open; termux-open-url; wslview

   # uDev: Since DRYa is developing traitsID, then in the future we will get our OS from an environment variable made by DRYa

   # Test in which OS this script is running:
      v_uname=$(uname -a)

   # from the list o arguments, send links to an array, send non-links to another array
      # Unseting array variabls, so that they start empty
         unset link links          # Erasing the contents of the 'links' variable/array
         unset non_link non_links  # Erasing the contents of the 'non_links' variable/array
         #unset ls_detected_files
         #unset op_special_commands
         #unset saved_recognized_files

      # Filtering the arguments 
      #  for i in $*
      #  do
      #     # Testing each arg
      #        link=$(echo $i | grep "^http")         # Attempt to detect if a given argument is a link
      #        non_link=$(echo $i | grep -v "^http")  # Ateempt to detect if a given argument is not a link (by inverting the grep search with -v)

      #     # For debug, verbose var:
      #        echo "arg: $i"

      #     # If var if link, go to Variable A; If var is non_non link, go to var B  (WITH VERBOSE, FOR DEBUG)
      #        [[ ! -z $link ]] && echo "'link' var is: $link" && \
      #        links+=("$link")  # If variable 'link' comes with some value (meaning that we detected a link) then, append it to the array 'links'

      #        [[ ! -z $non_link ]] && echo "'non_link' var is: $non_link" && \
      #        non_links+=("$non_link")
      #  done

      # Verbose results (for debug):
      #  echo
      #  echo "------------------------------"
      #  echo "'links' array: ${links[@]}"
      #  echo "'non_links' array: ${non_links[@]}"
      #  #read; clear; exit 0  # For testing only

   # Try to find the file opener at each OS:
      if [[ $v_uname =~ "Microsoft" ]]; then  # Test if this script is a Linux OS running inside windows (WSL (Windows sub-system for Linux):
         /mnt/c/windows/explorer.exe $*  # Original script, without a for loop
   
           # uDev: For links and non_links open accordingly:   
           #   # open each link
           #      for i in ${links[@]}
           #      do 
           #         /mnt/c/windows/explorer.exe $links  #Error: windows explorer does not open links
           #      done
           #
           #   # open each non_link
           #      for i in ${non_links[@]}
           #      do 
           #         /mnt/c/windows/explorer.exe $non_links
           #      done

      elif [[ $v_uname =~ "Android" ]]; then  # If it finds "Android" then it should be working at Termux terminal
            xdg-open $*
            # uDev: usar `termux-open --chooser`

      elif [[ $v_uname =~ "Linux" ]]; then  # If it is Any kind of Linux, try to open as standard
            xdg-open $*
      else
         echo "DRYa: 'op' command failed to open the arguments"
      fi
      
      # uDev: Add 'termux-open $* --chooser' as an option

      # uDev: '$ op grep 20240114_094706.jpg' para procurar 'grep' pela foto certa
      #       '$ op grep mv 20240114_094706.jpg' para mover a foto encontrada (precisa de um menu interativo)
}


# Ask the terminal to print the stroken
   alias stroken="cat ${v_REPOS_CENTER}/DRYa/all/etc/dot-files/git-github/current-stroken"
   # Notes:
      # At ${v_REPOS_CENTER}/DRYa/all/install.uninstall/stroken there is a copy of this file but with kore info to help new app users
      # We can install stroken automatically with: '$ drya install stroken'

alias website="termux-open-url https://seiva.yolasite.com/ 2>/dev/null || op https://seiva.yolasite.com/"

#alias car="Abre uma copia da imagem GPS-view-casa para marcar na imagem onde ficou o carro (apagando a imagem anterior)" # Serve para quando se estaciona o carro em casa (na cidade, porque nunca se estaciona no mesmo sitio)

alias all="cd all; ls"

function notify {
   # Criar notificacoes via termux

   # uDev: --------------------------------------------------------------
      function ouvir {
         # Cria um while loop infinito por exemplo no smartphone Indratena que ouve updates no github, baixa, instala, executa
         # Usará um ficheiro em verbose-lines e jarve-sentinel
         # uDev: Criar na wikiD um header que informa todos os sitios onde a DRYa mexe com o github
         echo "DRYa: Listener: uDev"
      }

      function falar {
         # uDev: Cria uma notificacao noutro Android, via um ficheiro verbose-lines e jarve-sentinel
         echo "DRYa: Speaker: uDev"
      }
   # --------------------------------------------------------------------

   clear
   figlet "DRYa Notify"
   #f_talk; 
   echo "Notify: Create an Android notification message"

   # Creating an history file
      # uDev: enviar antes para omni-log repo
      v_dir=~/.config/h.h/drya/tmp/
      v_file="termux-notify-output.txt"
      mkdir -p $v_dir
      v_file2=${v_dir}${v_file}
            
   # Create an ID for each notification created
      function f_create_id {
         # It will be a concat of year + month + day + hour + Min + Sec
         # It will be a concat of  %Y  +  %m   +  %d +  %k  +  %M +  %S
         v_date=$(date +%Y%m%d%k%M%S)
         v_id=$v_date
      }

   # Add a line to history file
      function f_create_hist {
            echo "$(date) > $v_ans" >> ${v_dir}${v_file}
      }

   # Create the message itself
      function f_notify_create {
         termux-notification -t "DRYa: Notify:" -c "$v_ans" -i "$v_id" --icon circle_notifications --image-path /data/data/com.termux/files/home/Repositories/DRYa/all/etc/dot-files/termux/termux-icon.png && echo "Sucess!"
      }

   # Input a message
      function f_notify_message {
         echo
         echo "What is your message? "
         read -p " > " v_ans

         f_create_id
         f_notify_create
         f_create_hist
      }

   # Echo notification ID number
      function f_change_id {
         echo
         echo "Id for this notification will be: "
         echo " > $v_id"
      }

   # No arg:
      if [[ -z $1 ]]; then
         f_change_id
         f_notify_message

   # If arg -i is given to '$ notify' then, add the change to alter the ID
      elif [[ $1 == "-i" ]]; then
         f_change_id
         echo
         echo " >> What is your custom notification ID?"
         echo "     (will overwrite any notification with same ID)"
         read -p "     > " v_id
         echo
         f_change_id
         f_notify_message

   # List all DRYa messages (only DRYa)
      elif [[ $1 == "-l" ]]; then
         termux-notification-list | grep -B 2 -A 7 "tag"

   # For each line in 'notify' history file, notify it again. (If you dont want the same history file to come up, delete such line)
      elif [[ $1 == "again" ]]; then

         echo

         while read i; do
            v_ans=$(echo "$i" | cut -d ">" -f 2 | sed "s/ //")
            echo $v_ans
            f_create_id
            f_notify_create
         done < $v_file2
         
   # Edit the history file
      elif [[ $1 == "m" ]] || [[ $1 == "mod" ]] ; then
         vim $v_file2
         
      elif [[ $1 == "-h" ]]; then
         echo
         echo "Manipulate ID: "
         echo " > notify -i"

      elif [[ $1 == "-v" ]]; then
         less ${v_dir}${v_file}
      fi
      
     
}
alias nt="notify"

function nfc {
   # Read and write NFC on termux
      clear
      figlet NFC
      echo "DRYa: Ler NFC (short)"

      # Creating a file to hold nfc content temporarily
         v_nfc=~/.tmp/termux-nfc-tmp-text
         mkdir -p ~/.tmp
         touch $v_nfc

      # Example sound
         v_sound=~/Repositories/DRYa/all/etc/sounds/example-sound-completion-bell.wav

      termux-nfc -r short > $v_nfc

      echo
      echo -n "NFC lido: "

      #read -p "Press Enter AFTER reading"

      v_nfc_text=$(grep "Payload" $v_nfc )

      if [[ $v_nfc_text =~ "nfc-base1" ]]; then
         echo "Base 1"

         termux-wake-lock

         v_secs=$((60 * 60))
         while [ $v_secs -gt 0 ]; do
            echo -ne "\r$v_secs"
            sleep 1
            : $((v_secs--))
         done

         echo
         termux-media-player play $v_sound 1>/dev/null
         termux-wake-unlock

      elif [[ $v_nfc_text =~ "nfc-MLavar1-start" ]]; then
         echo "Maquina de lavar: Inicio"

         for i in {1..60};
         do
            echo $i
            sleep 1
         done

      elif [[ $v_nfc_text =~ "nfc-MLavar1-end" ]]; then
         echo "Maquina de lavar: Fim"

      else
         echo $v_nfc_text
      fi
}

alias py="python3"
alias pip="pip3"

alias timg="termimage"

# uDev: alias dnf-apt-pkg-pacman = X

function clc {
   # dee: in Bash there is  very good calculator caled 'bc', but it's command is not very intuitive
   clear
   figlet Best Calculator
   echo "Best Calculator (interactive) 'bc':"
   echo " > Make some math"
   echo
   bc --quiet
}

alias   t-play="termux-media-player play"
alias  t-pause="termux-media-player pause"
alias   t-stop="termux-media-player stop"
alias   t-info="termux-media-player info"
alias  t-sound="termux-media-player play ${v_REPOS_CENTER}/DRYa/all/etc/sounds/example-sound-completion-bell.wav" ## example sound
alias t-sound1="mpv ${v_REPOS_CENTER}/DRYa/all/etc/sounds/example-sound-completion-bell.wav > /dev/null 2>&1 & pid=$!" ## example sound

alias tufnar="echo '# uDev: Tufnar Isaura 91... Check a phone list on omni-log" 

function hr {
   # Fx para adicionar novos horarios do trabalho e visual os que ja existem

   clear
   figlet DRYa

   echo "DRYa: Gerir Horario"

   # Lista de diretorios onde é possivel encontrar mais imgs de horarios
   # 
   #   cd /storage/0123-4567
   #   cd /storage/
   #   cd /storage/83DB-10EA || cd /storage 
   #   cd /sdcard/Termux-bridge-Android
   #
   
   # Lista de opcoes para o menu `fzf`
      L4="4. Registar  | Horas apos o turno (upK)" 
      L3="3. Ver       | Todos os Horarios anteriores"
      L2="2. Adicionar | Horario novo"
      L1="1. Ver       | Horario atual"

      v_list=$(echo -e "$L1 \n$L2 \n$L3 \n$L4" | fzf --cycle --prompt="DRYa: Gerir Horario: ")

   # Perceber qual foi a escolha da lista
      [[ $v_list =~ "1" ]] && echo " > $L1 (uDev)" 
      [[ $v_list =~ "2" ]] && echo " > $L2 (uDev)" 
      [[ $v_list =~ "3" ]] && echo " > $L3 (uDev)" 
      [[ $v_list =~ "4" ]] && echo " > $L4"; upk
      unset v_list

      echo
}

function shebang {
   # It creates a bash script (if no args are input)
      # Or gives a shebang to the file you input as argument 1)
      # It also changes the permissions of tbe file to executable

   function f_inform_creation_noArgs {
      # Informing the user that the process is ready
      
      # Using command 'ls' to test existence
         ls $v_ans 1>/dev/null # Delete all output
         if [[ $? == 0 ]]; then # If last '$ ls' command was sucessfull, then:

            tput setaf 3
               echo -n " > File "
            tput setaf 4
               echo -n $v_ans
            tput setaf 3
               echo " created!"
            tput sgr0

            read -s -n 1
            vim $v_ans
         else 
            echo File not created
         fi
   }

   function f_inform_creation {
      # Informing the user that the process is ready

      
      # Using command 'ls' to test existence
         ls $i 1>/dev/null # Delete all output
         if [[ $? == 0 ]]; then

            tput setaf 3
               echo -n " > File "
            tput setaf 4
               echo -n $i
            tput setaf 3
               echo " created!"
            tput sgr0
         else 
            echo File not created
         fi
   }

   function f_test_existence_noArgs {
      # Test existence of file named as argument given

      if [[ -f $v_ans ]]; then
         # Test if file exists to avoid overwriting it
         echo -n "File "
         tput setaf 4
         echo -n "$v_ans "
         tput sgr0
         echo "already exists, please choose another name"
      else 
         # If file does not exist, run:
         touch $v_ans
         echo "#!/bin/bash" > ./${v_ans}
         chmod +x ./${v_ans}

         f_inform_creation_noArgs
         vim $v_ans

      fi
   }

   function f_test_existence {
      # Test existence of file named as argument given

      if [[ -f $i ]]; then
         # Test if file exists to avoid overwriting it
         echo -n "File "
         tput setaf 4
         echo -n "$i "
         tput sgr0
         echo "already exists, please choose another name"
      else 
         # If file does not exist, run:
         touch $i
         echo "#!/bin/bash" > ./${i}
         chmod +x ./${i}
         
         f_inform_creation 

      fi
   }

   if [[ -z $1 ]]; then
      # If no arg is given
         echo -n " > File name? "
         read v_ans

         f_test_existence_noArgs

   else 
      # If there are arguments, test each one for exuatence:
         for i in $@; do 
            f_test_existence
         done
   fi
}


function go {
	# This function opens applications apart from the terminal. It means that you can close the terminal after the aplications launch and the terminal being killed does not kill the apps it created
	for v_arg in $@
	do
		setsid $v_arg &>/dev/null
	done

      # Detecting if any of the arguments given has the word "terminal" to replace for "gnome-terminal"
      if [[ $@ =~ "terminal" ]]; then setsid gnome-terminal &>/dev/null; fi


      # Detect if LAST argument is "bye" to make the current terminal "exit"
         # Store all arguments inside a variable
         v_allArguments=$*
         
         # Using awk to detect only the last argument
         v_lastArg=$(echo $v_allArguments | awk '{ print $NF }')
         if [ ${v_lastArg} == "bye" ]; then 
            #echo "bye was said. Press enter to exit"    #Exit message
            #read                                        #Pause before exit
            exit
         fi

      # If there is an app called "bye" that you want to open with the command "go" then just put something else in from of it to prevent "exit" command to happen
         # Use: $ go bye ...

      # If you simply want to restart the terminal
         if [ $1 == "again" ]; then gnome-terminal && exit; fi

   # If you want to export just this "go" script for an entire repository, the name sugested is: bash-open-app-at-external-window
}

# This command is same as: "source ~/.bashrc" (but needs the function: go)
alias src="go gnome-terminal; exit"
alias f5="source ~/.bashrc"


alias ,="cd"
alias ,,="clear; tput cnorm" # Also resets the blinking cursor if it was hidden
alias ,,,=", ; ,," # Same as both 2 previous commands put together
alias .,="ls -Ap" # uDev: This is meant also to SEE if the directory is empty or not, therefore, if the dir is Totally empty, echo "This place is empty"
alias CLEAR="cd; clear; figlet 'Clear'; tput cnorm" # Also resets the blinking cursor if it was hidden
alias sh="bash"

function f_emacs {
   # Attempt to untangle emacs alias (due to so many versions)
   
   alias em="emacs"
   alias Em="/mnt/c/Program\ Files/Emacs/x86_64/bin/emacs.exe" # Opens emacs GUI on windows OS
   alias Emacs="/mnt/c/Program\ Files/Emacs/x86_64/bin/emacs.exe" # Opens emacs GUI on windows OS
   alias ems="emacs --script"

   # Decide for alias EM which emacs corresponds best with the System
      if [ -f /mnt/c/Program\ Files/Emacs/x86_64/bin/emacs.exe ]; then 
         # If emacs GUI exists (on windows), then
         alias EM="/mnt/c/Program\ Files/Emacs/x86_64/bin/emacs.exe" 

      else 
         ## If emacs GUI does not exist, then set it for terminal emacs
         alias EM="emacs"
      fi
}
f_emacs

alias a="cd all && ls"
alias hi="hello!"

# uDev: to put under menuFAV F
alias hind="vim ${v_REPOS_CENTER}/yogaBashApp/all/about-hinduism/about-hinduism.txt"


# Pandoc app to create man pages

alias ca="bash ${v_REPOS_CENTER}/DRYa/all/bin/ca-lculadoras.sh"

# Acessing emacs-wiki.org
   alias emacs-wiki="emacs ${v_REPOS_CENTER}/dWiki/emacs/gnu-emacs/emacs-wiki.org" #Add message "file: ~/Repos.../x.../y.../z... was opened" >> ~/.tmp/messages.txt

# Acessing emacs init.el file
   alias emacs-init="emacs ~/.emacs.d/init.el"




function f_hibernate {
   if [ $traits_OS == "Windows" ]; then
      cd ${v_REPOS_CENTER}/DRYa/all/batch/shut-restart-hibernate-sleep/
      /mnt/c/Windows/System32/cmd.exe /c hibernar.lnk

   elif [ $traits_OS == "Linux" ]; then
      sudo systemctl hibernate
   fi
}

function f_restart {
   if [ $traits_OS == "Windows" ]; then
      cd ${v_REPOS_CENTER}/DRYa/all/batch/shut-restart-hibernate-sleep/
      /mnt/c/Windows/System32/cmd.exe /c reiniciar.lnk

   elif [ $traits_OS == "Linux" ]; then
      shutdown -r now
   fi
}

function f_shutdown {
   if [ $traits_OS == "Windows" ]; then
      cd ${v_REPOS_CENTER}/DRYa/all/batch/shut-restart-hibernate-sleep/
      /mnt/c/Windows/System32/cmd.exe /c desligar.lnk
   
   elif [ $traits_OS == "Linux" ]; then
      shutdown now
   fi
}




function f_fzf_power_options {
   # POWER OPTIONS: Using Num Pad numbers as shortcuts

   # Menu
      # ------------------------------------------ #
      L9="A. Abort (Restart and Shutdown)          "
      L8="T. Temporizar acções                     "
      # ------------------------------------------ #
      
      L7="6. Refresh   | (F5)                      "
      L6="8. Reiniciar | Reeboot  | Restart        "
      L5="2. Hibernar                              "
      L4="4. Suspender                             "
      L3="0. Desligar  | Encerrar | Shutdown | OFF "
      L2="5. Bloquear ecra                         "
      L1="1. Cancel                                "
      # ------------------------------------------ #
      L0="POWER Options: "

      v_list=$(echo -e "$L1 \n$L2 \n$L3 \n$L4 \n$L5 \n$L6 \n$L7 \n\n$L8 \n$L9" | fzf --cycle --prompt="$L0")

   # Perceber qual foi a escolha da lista
      [[ $v_list =~ "0" ]] && echo "Desligar" && f_shutdown  # Desliga a maquina
      [[ $v_list =~ "5" ]] && echo "Detetado 5 (debug)"
      [[ $v_list =~ "4" ]] && echo "Suspender" && systemctl suspend
      [[ $v_list =~ "2" ]] && echo "Hibernar" && f_hibernate
      [[ $v_list =~ "6" ]] && echo "Detetado 6 (debug)"
      [[ $v_list =~ "8" ]] && echo "Reiniciar" && f_restart  # Restart à maquina
}


   # uDev: Vai have uma fx para cada comando e os alias numerios + os alias escritos chamam essa fx.
      # Dica: Pode ser usado o teclado numerico para escrever: Exemplo tecla 1: 'nada'; tecla 2: 'ABC'; tecla 3: 'DEF'; tecla 4: 'GHI' ...
   alias           exe="/mnt/c/Windows/System32/cmd.exe /c"
   alias        24685="f_fzf_power_options"
   alias        246855="echo 'Lock Screen'"
   alias        246852="echo 'Shutdown'; shutdown now"
   alias        246858="echo 'Restart'; shutdown -r now"
   alias        246850="echo 'Hibernete'; win-hibernate 2>/dev/null|| echo ' > This command is for Windows only'"
   alias        246851="echo 'Suspend'"
   alias      shutdown="shutdown -r now"
   alias        reboot="shutdown -r now"
   alias       restart="shutdown -r now"
   alias   lock-screen="shutdown -r now"
   alias     hibernate="shutdown -r now"
   alias        reboot="shutdown -r now"
   alias         xkill="echo 'Activate gnome xKill to force GUI apps to close'"

   alias    48256="termux-microphone-record -d 1>/dev/null" # Starts voice recording without any terminal output
   alias "48256."="termux-microphone-record -q 1>/dev/null" # Stops voice recording without any terminal output
   alias      453="upk"

alias bashrc="vim ~/.bashrc"
alias vimrc="vim ~/.vimrc"

function teste {
   echo "Teste do uso de placeholder %s em bash com printf"

   # Teste 1
      name=Alice
      printf "Hi, %s \n" "$name"

   # Teste 2
      name=Alce
      printf "Hi, %s \n" \
      "$name"

   # Teste 3
      name1=Alface
      name2=Ale
      printf "Hi, %s %s \n" \
      "$name1" \
      "$name2"
}

function hist {
   # history-recall sub-app
   mkdir -p ~/.tmp/
   history > ~/.tmp/fileA.txt
   history

   echo -e "\n > Type Ctrl+C to cancel \n > Type a number to navigate: "
   echo -n " > "
   read v_ans

   #echo "grep results:"

   grep "$v_ans" ~/.tmp/fileA.txt > ~/.tmp/fileB.txt

   # Remove 2 character to the begining of the text
   sed -i 's/^..//g' ~/.tmp/fileB.txt

   # Debugging process
   #echo "Sed results:"
   #echo "cat fileB"
   #cat ~/.tmp/fileB.txt

   # Search patter of the beggining of the line
   grep ^$v_ans ~/.tmp/fileB.txt > ~/.tmp/fileA.txt

   # Debugging process
   #echo "cat fileA"
   #cat ~/.tmp/fileA.txt
   sed -i 's/^\w*\ *//' ~/.tmp/fileA.txt

   # Now, cutting the command
   cut -d ' ' -f2- ~/.tmp/fileA.txt

   # Debugging process
   #echo "fileA after cut"
   #cat ~/.tmp/fileA.txt
   #echo "trying to eval:"
   #read

   # Creating a variable called v_eval to store the content of the file as text
   v_eval=$(cat ~/.tmp/fileA.txt)

   # Trying to run the text of the file. If it the shell has executables that are called the same way as this txt is written, then run this text at the terminal as if it was written to trigger an executable
   eval $v_eval
}




# Temporary script to map audio chapters in a file currently being studied
   alias eoc="echo 'end of chapter, right?'; echo >> ~/eof; info 1>>~/eoc"

# Bash fork bomb
   # Link tutorial: https://youtu.be/wIsGXkxXZzE
   alias start-fork-bomb=":() { :|: & };:"

# Verbose file (variables and outputs)
   echo "DRYa: File ended loading: DRYa's $v_title" >> $v_MSGS

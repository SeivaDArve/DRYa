#!bin/bash

# Title: config-bash-alias
# Description: Dv List of all alias and Functions (for Linux terminal)
# Use: This file is meant to be sourced from "~/Repositories/DRYa/all/source-all-drya-files"
# Version: beta
# 
# Install this file
#   1. open ~/.bashrc
#   2. paste: "source ~/Repositories/DRYa/all/source-all-drya-files"
#

function f_cor1 { 
   tput setaf 5
}

function f_cor2 { 
   tput setaf 6 
}
function f_cor3 { 
   tput setaf 8 
}
function f_resetCor { 
   tput sgr0 
}

function f_verbose_start-2 {
   # File Description
      echo "DRYa: File running: config-bash-alias" 
   # Use Figlet app to write a Title
      figlet Dv 
}
f_verbose_start-2

function f_OS_detect {
   # uDev: move this into the installer
   #Detect Terminal and OS to create compatibility 
      OS=$(uname -o)
      mkdir -p ~/.config/h.h/drya/
      echo "OS Detected: $OS" > ~/.config/h.h/drya/drya-detections.txt
}
f_OS_detect


# Set the keybindings to vi/vim mode:
   #set -o vi

function f_horizontal_line {
   # This function calculates the amount of line present in the terminal window for the current zoom and creates an horizontal line across the screen

         v_count="$COLUMNS"
            #echo -e "There are currently $v_cols columns in the screen \n and from that number, $v_count is the\n number of dashes '-' that the menu will have "
            #read

         # You may choose the apropriate symbol here
            v_underscore="-"

         # Store in a var, how many dashes can be replaced by empty spaces (according to the specific amount of available columns)
            v_underscoreCount=""

            for e in $(seq $v_count); do 
               v_underscoreCount="$v_underscoreCount$v_underscore"
            done

         

         # The result is an horizontal line
            #echo "var is $v_underscoreCount"
            #read
            v_line=$v_underscoreCount

            # removing last 4 characters from v_line. This way it can be used in SELECT menus
               v_line2=${v_line::-4}

            echo $v_underscoreCount
}

function e {
   select i in Nano Vim; do 
      case $i in 
         Nano)
	         if [ $_ans == "1" ]; then alias r="nano"; fi
         ;;
         Vim)
            if [ $_ans == "2" ]; then alias r="vim"; fi
         ;;
      esac
      done
	
}

alias siigo="termux-open-url https://siigo-maintenance.com/#/calendar"

# Termux alias
   alias rec="termux-microphone-record -d" # Starts voice recording (There should be a fast dial for this option)
   alias cer="termux-microphone-record -q" # Stops voice recording (There should be a fast dial for this option)
   alias paste="termux-clipboard-get"
   alias sms="termux-sms-send -n" 

# Termux sms script
   function sms {
      case $1 in
         send)
            v_1="-n $2"
            v_2=$3
            echo "termux-sms-.. $v_1 $v_2" 
         ;;
         in)
         ;;
         out)
         ;;
         *)
         ;;
      esac
}


alias grep="grep --color=auto"

function bt {
   # See battery status
   
   if [ $(uname -o) == "Android" ]; then
      termux-battery-status
   else
      case $1 in 
         -a) upower -i `upower -e | grep 'BAT'` ;;
         -p) echo -n "Battery percentage = " && cat /sys/class/power_supply/BAT0/capacity ;;
         *) upower -i $(upower -e | grep BAT) | grep --color=never -E "state|to\ full|to\ empty|percentage" 
         ;;
      esac
   fi
}

function f_debug {
   # Degug function: use it when you need to re-open this file over and over again for debug.
	read
	vim ${v_REPOS_CENTER}/DRYa/all/config-bash-alias
	#pkill -9 -x ~/Repositories/DRYa/all/config-bash-alias
}

function f_drya-messages {
   # All Seiva's software (including DRYa)
      # will have at the start of the file,
      # a line that
      # will tell ~/.tmp/drya-messages.txt
      # that that specific file was read.
      # This is for debugging process.
      # You can add a line to ~/.bashrc to delete
      # ~/.tmp/ everytime you open the terminal
      # and that way, everything is refreshed everytime

      alias drya-messages="less ~/.tmp/drya-messages.txt" #uDev: change to .dryarc  ## uDev: to be sent to drya.sh
}

# joke:
   alias research="tree /;tree /;tree /;tree /;tree /;tree /;tree /;tree /;tree /;tree /;tree /;tree /;tree /";

alias ls="ls -p"
alias la="ls -pA"
alias ll="ls -pl"
alias mk="mkdir" # Creates one directory for each name given as an argument and in case that succeeds, changes working directory for the directory given as the first argument
alias dcim='cd ~/storage/dcim/Camera || echo " \> You are trying to navige to a dir usually present on Android using Termux"'

# Instagram tools:
   alias miau="termux-open-url https://www.instagram.com/reel/CinlDmBO0tO/?igshid=YmMyMTA2M2Y="
   alias preta="termux-open-url https://www.instagram.com/reel/Cnol075KSIU/?igshid=YmMyMTA2M2Y="

function op {
   # Function to open all files and directories given as arguments ($*)
      # Similar apps: termux-open; termux-open-url; wslview

   # Test in which OS this script is running:
      v_uname=$(uname -a)

   # Try to find the file opener at each OS:
      if [[ $v_uname =~ "Microsoft" ]]; then 
         # Test if this script is a Linux OS running inside windows (WSL (Windows sub-system for Linux):
            /mnt/c/windows/explorer.exe $*

      elif [[ $v_uname =~ "Android" ]]; then
         # If it finds "Android" then it should be working at Termux terminal
            xdg-open $*

      elif [[ $v_uname =~ "Android" ]]; then
         # If it is Any kind of Linux, try to open as standard
            xdg-open $*
      else
         echo "DRYa: op: Attempt to open that argument failed"
      fi
      
      # uDev: Add 'termux-open $* --chooser' as an option
}


function stroken {
   echo "seivadarve"
   echo "ghp_JGIFXMcvvzfizn9OwAMdMdGMSPu9E30yVogPk"
}

# Fast dial:
   alias 2468="exit"
   alias 24685="shutdown now"
   alias 246854="shutdown -r now"
   alias 48256="termux-microphone-record -d 1>/dev/null" # Starts voice recording without any terminal output
   alias "48256."="termux-microphone-record -q 1>/dev/null" # Stops voice recording without any terminal output

alias play="termux-media-player play"
alias pause="termux-media-player pause"
alias stop="termux-media-player stop"
alias info="termux-media-player info"

alias tufnar="echo '# uDev: Tufnar Isaura 91..." 

function shebang {
   # It creates a bash script (if no args are input)
      # Or gives a shebang to the file you input as argument 1)
      # It also changes the permissions of tbe file to executable

   function f_inform_creation_noArgs {
      # Informing the user that the process is ready
      
      # Using command 'ls' to test existence
         ls $v_ans 1>/dev/null # Delete all output
         if [[ $? == 0 ]]; then # If last '$ ls' command was sucessfull, then:

            tput setaf 3
               echo -n " > File "
            tput setaf 4
               echo -n $v_ans
            tput setaf 3
               echo " created!"
            tput sgr0
         else 
            echo File not created
         fi
   }

   function f_inform_creation {
      # Informing the user that the process is ready

      
      # Using command 'ls' to test existence
         ls $i 1>/dev/null # Delete all output
         if [[ $? == 0 ]]; then

            tput setaf 3
               echo -n " > File "
            tput setaf 4
               echo -n $i
            tput setaf 3
               echo " created!"
            tput sgr0
         else 
            echo File not created
         fi
   }

   function f_test_existence_noArgs {
      # Test existence of file named as argument given

      if [[ -f $v_ans ]]; then
         # Test if file exists to avoid overwriting it
         echo -n "File "
         tput setaf 4
         echo -n "$v_ans "
         tput sgr0
         echo "already exists, please choose another name"
      else 
         # If file does not exist, run:
         touch $v_ans
         echo "#!/bin/bash" > ./${v_ans}
         chmod +x ./${v_ans}

         f_inform_creation_noArgs
         vim $v_ans

      fi
   }

   function f_test_existence {
      # Test existence of file named as argument given

      if [[ -f $i ]]; then
         # Test if file exists to avoid overwriting it
         echo -n "File "
         tput setaf 4
         echo -n "$i "
         tput sgr0
         echo "already exists, please choose another name"
      else 
         # If file does not exist, run:
         touch $i
         echo "#!/bin/bash" > ./${i}
         chmod +x ./${i}
         
         f_inform_creation 

      fi
   }

   if [[ -z $1 ]]; then
      # If no arg is given
         echo -n " > File name? "
         read v_ans

         f_test_existence_noArgs

   else 
      # If there are arguments, test each one for exuatence:
         for i in $@; do 
            f_test_existence
         done
   fi
}


function go {
	# This function opens applications apart from the terminal. It means that you can close the terminal after the aplications launch and the terminal being killed does not kill the apps it created
	for v_arg in $@
	do
		setsid $v_arg &>/dev/null
	done

      # Detecting if any of the arguments given has the word "terminal" to replace for "gnome-terminal"
      if [[ $@ =~ "terminal" ]]; then setsid gnome-terminal &>/dev/null; fi


      # Detect if LAST argument is "bye" to make the current terminal "exit"
         # Store all arguments inside a variable
         v_allArguments=$*
         
         # Using awk to detect only the last argument
         v_lastArg=$(echo $v_allArguments | awk '{ print $NF }')
         if [ ${v_lastArg} == "bye" ]; then 
            #echo "bye was said. Press enter to exit"    #Exit message
            #read                                        #Pause before exit
            exit
         fi

      # If there is an app called "bye" that you want to open with the command "go" then just put something else in from of it to prevent "exit" command to happen
         # Use: $ go bye ...

      # If you simply want to restart the terminal
         if [ $1 == "again" ]; then gnome-terminal && exit; fi

   # If you want to export just this "go" script for an entire repository, the name sugested is: bash-open-app-at-external-window
}

# This command is same as: "source ~/.bashrc" (but needs the function: go)
alias src="go gnome-terminal; exit"


# function ls {
# case !$ in 
#	l) 
		#It means "ls l" insteas of ls -l
#	;;
#	a) 
		#It means "ls a" insteas of ls -a
#	;;
#	*)
#	;;
# esac

function . {
   # Navigate through the file system stupidly ez
   
   # uDev: Include 'function d' to give 'favs' if directory is not found

      if [ -z $1 ]; then 
         # If no argument is given, lists storage (ls command)
         ls 

      elif [ $1 == "." ]; then 
         # If arg 1 is '.' then navigate to the center of seiva's repos
         cd $v_REPOS_CENTER
         # uDev: this command '. .' is usually issued at thr beggining of the day when the user is going to start the coding session. Therefore: Echo once a day to REMEMBER to git pull
   
      elif [ ! -z $1 ]; then
         # If argument is given and it is a dir, cd into it, otherwise if it a file, edit it
         cd $1 || vim $1
      fi
}

#alias .="ls"  ## Replaced by the 'function . { }' and the 'function d { }'
alias ..="cd .."
alias ...="cd -"
alias ....="pwd"
alias ,="cd"
alias ,,="clear; tput cnorm" # Also resets the blinking cursor if it was hidden
alias .,="ls -Ap" # uDev: This is meant also to SEE if the directory is empty or not, therefore, if the dir is Totally empty, echo "This place is empty"
alias A="cd; clear; figlet 'Clear'; tput cnorm" # Also resets the blinking cursor if it was hidden


# Pandoc app to create man pages

function nPpN-dir-looper {
   # (looper app) Save a loop of directories:
      alias P="Positive dir"  #uDev: Adds current dir to loop
      alias N="Negative dir"  #uDev: Removes current dir from loop
      alias p="previous dir"  #uDev: Swap to previous dir present in the loop 
      alias n="next dir"      #uDev: Swap to next dir present in the loop
      # np | pn | Np | Pn) list all dirs and current one
      function P {
         mkdir -p ~/.config/h.h/nPpN-dir-looper
         pwd >> ~/.config/h.h/nPpN-dir-looper/nPpN-list.txt
          
      }

      # Curiosity: by typing '$ man termux' you can see that by coincidence and also by luck, termux uses the volume key <Up> to perform control over the terminal and over the smartphone.
         # Two of those Volume Up shorcut control are:
         # 'Volume key Up + P': Page Up
         # 'Volume key Up + N': Page Down
         # To make it even better, remember that the command ZZ in Vim, puts the current line at the middle of the screen.
            # These 3 commands allow you to see before, after and around your current line in the current file
}
nPpN-dir-looper

# Acessing omni-log-Dv files
alias v-omni="vim ${v_REPOS_CENTER}/omni-log-Dv/multiplex.org"
alias e-omni="emacs ${v_REPOS_CENTER}/omni-log-Dv/multiplex.org"
alias omni="emacs ${v_REPOS_CENTER}/omni-log-Dv/multiplex.org"
alias omni-n-push-n-exit="vim ${v_REPOS_CENTER}/omni-log-Dv/multiplex.org; echo 'git add -A + git push (will be added soon)'; exit"
alias test="tree /; exit 0"

alias R='echo "List Repositories by number and jumpt to them. uDev: Not available yet"'

# Acessing emacs-wiki.org
alias emacs-wiki="emacs ${v_REPOS_CENTER}/dWiki/emacs/gnu-emacs/emacs-wiki.org" #Add message "file: ~/Repos.../x.../y.../z... was opened" >> ~/.tmp/messages.txt

# Acessing emacs init.el file
alias emacs-init="emacs ~/.emacs.d/init.el"

# Using Num Pad numbers as shortcuts
alias 2468="exit"
alias 24685="shutdown now"
alias 246854="shutdown -r now"


alias bashrc="vim ~/.bashrc"
alias vimrc="vim ~/.vimrc"


# <drya ,.... menu>
   # DRYa sub-files are usually called by ,..... alias:
      # Multiple ways to edit this file # PERMANENT CHANGES if "git push" is used
         alias edit-alias="vim ${v_REPOS_CENTER}/DRYa/all/etc/config-bash-alias"
         #alias ,.="vim ~/Repositories/DRYa/all/etc/config-bash-alias" ## This line is already set at 'source-all-drya-files'

      # Edit source-all-drya-files:
      alias edit-sources="vim ${v_REPOS_CENTER}/DRYa/all/source-all-drya-files"
      alias ,..="vim ${v_REPOS_CENTER}/DRYa/all/source-all-drya-files"

      # Edit dotFiles
      function ,... {

         f_horizontal_line #If variable v_line is needed, this function must run before to create it
         clear

         echo SELECT file to edit by Title
         echo

         # Change the prompt message:
         PS3="Select a file to edit: "

         COLUMNS=0
         select opt in $v_line2 config-bash-alias source-all-drya-files source-all-moedaz-files .bashrc .vimrc com.list-econ-items.txt com.associative-array SOURCE 1st "emacs-init (emacs)" "emacs-init (vim)" quit $v_line2; do
            case $opt in
               config-bash-alias)
                  ,.
                  break
                  ;;
               source-all-drya-files)
                ,..
               ;;
             .bashrc)
               vim ~/.bashrc
               break
               ;;
             source-all-moedaz-files)
               
               ;;
            com.list-econ-items.txt)
               vim ${v_REPOS_CENTER}/moedaz/all/var/com.list-econ-items.txt
               ;;
            com.associative-array)
               vim ${v_REPOS_CENTER}/moedaz/all/var/com.associative-array
               ;;
             .vimrc)
                  vim ~/.vimrc
               ;;
            SOURCE)
               clear
               source ~/.bashrc
               break
               ;;
            1st)
               clear
               echo "Editing the list of 1st apps to install"
               read -s -t 2
               vim ${v_REPOS_CENTER}/DRYa/all/etc/1st/1st
               ;;
            "emacs-init (emacs)")
               # This edits the init file ALWAYS on the repo 'drya' first and THEN copies to ~
                  # This way we know we can easily upload the file
                  emacs ${v_REPOS_CENTER}/DRYa/all/dot-files/emacs/init.el
                  cp ${v_REPOS_CENTER}/DRYa/all/dot-files/emacs/init.el ~/.emacs.d/init.el
                  rm ~/.emacs; echo "drya: file removed: ~/.emacs"

                  # If we are on windows, the init file will be somewhere at %appdata%
                     if [ -d /mnt/c/Users/Dv-User/AppData/Roaming/.emacs.d ]; then
                        echo "Windows adjustment: %AppData% exists: copying init.el file there"
                        rm /mnt/c/Users/Dv-User/AppData/Roaming/.emacs 2>/dev/null
                        cp ${v_REPOS_CENTER}/DRYa/all/dot-files/emacs/init.el /mnt/c/Users/Dv-User/AppData/Roaming/.emacs.d/init.el
                     fi
                     
                  break
               ;;
            "emacs-init (vim)")
               # This edits the init file ALWAYS on the repo 'drya' first and THEN copies to ~
                  # This way we know we can easily upload the file
                  vim ${v_REPOS_CENTER}/DRYa/all/dot-files/emacs/init.el
                  cp ${v_REPOS_CENTER}/DRYa/all/dot-files/emacs/init.el ~/.emacs.d/init.el
                  rm ~/.emacs; echo "drya: file removed: ~/.emacs"

                  # If we are on windows, the init file will be somewhere at %appdata%
                     if [ -d /mnt/c/Users/Dv-User/AppData/Roaming/.emacs.d ]; then
                        echo "Windows adjustment: %AppData% exists: copying init file there"
                        rm /mnt/c/Users/Dv-User/AppData/Roaming/.emacs 2>/dev/null
                        cp ${v_REPOS_CENTER}/DRYa/all/dot-files/emacs/init.el /mnt/c/Users/Dv-User/AppData/Roaming/.emacs.d/init.el
                     fi
                  
                  break
               ;;
            quit)
               break
               ;;
             *) 
               echo "Invalid option $REPLY"
               ;;
           esac
         done

      }
alias edit-dotFiles=",..."
# </drya ,.... menu>
# Multiple ways to edit this file # PERMANENT CHANGES if "git push" is used
	alias update-alias="cd ${v_REPOS_CENTER}/DRYa/all/ && vim config-bash-alias"
	alias ,.="vim ${v_REPOS_CENTER}/DRYa/all/etc/config-bash-alias"
# Edit file source-all-drya-files
	alias ,..="vim ${v_REPOS_CENTER}/DRYa/all/source-all-drya-files"

#function ... {
#	clear
#	echo -e "Do you need any of these apps?\n"
#	echo " 1. history-manager"
#	echo " 2. do nothing"
#	read v_ans
#	case 1 in $v_ans
#}

# historyi-recall app
	function hist {
		mkdir -p ~/.tmp/
		history > ~/.tmp/fileA.txt
		history

		echo -e "\n > Type Ctrl+C to cancel \n > Type a number to navigate: "
		echo -n " > "
		read v_ans

		#echo "grep results:"

		grep "$v_ans" ~/.tmp/fileA.txt > ~/.tmp/fileB.txt

		# Remove 2 character to the begining of the text
		sed -i 's/^..//g' ~/.tmp/fileB.txt

		# Debugging process
		#echo "Sed results:"
		#echo "cat fileB"
		#cat ~/.tmp/fileB.txt

		# Search patter of the beggining of the line
		grep ^$v_ans ~/.tmp/fileB.txt > ~/.tmp/fileA.txt

		# Debugging process
		#echo "cat fileA"
		#cat ~/.tmp/fileA.txt
		sed -i 's/^\w*\ *//' ~/.tmp/fileA.txt

		# Now, cutting the command
		cut -d ' ' -f2- ~/.tmp/fileA.txt
		
		# Debugging process
		#echo "fileA after cut"
		#cat ~/.tmp/fileA.txt
		#echo "trying to eval:"
		#read

		# Creating a variable called v_eval to store the content of the file as text
		v_eval=$(cat ~/.tmp/fileA.txt)

		# Trying to run the text of the file. If it the shell has executables that are called the same way as this txt is written, then run this text at the terminal as if it was written to trigger an executable
		eval $v_eval
	}

# Alias morse-code-style
# Dot="."
# Dash=","
# word="..., ,.., .,,"
# alias .,

# To load upk Repo at .bashrc with .dryarc:
#cat upk.sh then search only for a function of greetings, then echo that out

function drya {
   if [ -z $1 ];
      # If drya is called with no arguments: 
      then 
         echo "no args"
         bash ~/Repositories/DRYa/drya.sh
   elif [ $1 == "catMe-dryarc" ];
      # If terminal: "$ drya catMe-dryarc":
      then
         echo "arg: catMe-dryarc"
         cat ~/.config/h.h/.dryarc
   else
      echo "need something?"
   fi
}

alias drya-editMe-permanently="vim ${v_REPOS_CENTER}/DRYa/all/config-bash-alias"
alias drya-editMe-temporarily="vim ${v_REPOS_CENTER}/DRYa/install.uninstall/drya.installer/future-dryarc"
#alias drya-updateMe-locally="cat ~/.config/h.h/.dryarc >> ${v_REPOS_CENTER}/DRYa/all/config-bash-alias && rm ~/.config/h.h/drya/.dryarc && creat .dryarc(with contents)" # This line copies temporary settings from users of drya and appends it to the directory where drya is installed and running. This way, if you push it to github, it will be permanent
alias drya-updateMe-globally="echo 'ezGIT must be installed'"
#alias drya-make-dryarc # uDev: function exists inside drya.sh

alias ..="cd .."
alias all="cd all && ls"
alias hi="echo hello"

alias sourceAll="source ~/.bashrc"

# function drya {
#   PS3="Select the operation: "
#   select opt in Configurations installations edit-files quit
#   do
#      case $opt in
#         Configurations)
#            read -p "Enter the first number: " n1
#            read -p "Enter the second number: " n2
#            echo "$n1 + $n2 = $(($n1+$n2))"
#            ;;
#         installations)
#            read -p "Enter the first number: " n1
#            read -p "Enter the second number: " n2
#            echo "$n1 - $n2 = $(($n1-$n2))"
#            ;;
#         edit-files)
#            read -p "Enter the first number: " n1
#            read -p "Enter the second number: " n2
#            echo "$n1 * $n2 = $(($n1*$n2))"
#            ;;
#         quit)
#            break
#            ;;
#         *)
#            echo "Invalid option $REPLY"
#            ;;
#      esac
#      # It works as a while loop too
#   done
#}



function hkllhcf {
   # If if you invoke "cdl" and no dir exists
   if [ ! -d "./$1" ]; then
      
      # A function that is needed to be prepared in case later on the code it is called:
      function f_cdl_mkdir {
         # Generate a random number to be used as a key to delete our previous directory if it was  reated by mistake
         declare v_random=$RANDOM

         # If a new directory is to be created, verbose descriptions will happen
         echo -n " > That directory "
         tput setaf 4
         echo -n $1
         tput sgr0
         echo " was not existent"
         echo "  > Therefore was created"
         echo -n "  > Delete it by executing "
         tput setaf 4
         echo $v_random
         tput sgr0
      }

      declare cur_dir=$1
      mkdir -p $1 
      f_cdl_mkdir
      cd $1
      ls

   else
      # If you invoke "cdl" and dir exists
      cd $1
      ls
      echo "normal run"
   fi
alias v="echo sk"
}

# Source all other repos if they exist:
# Source jarve
# Source upK
# Source ezGIT
# Source ... 


function drya-test {
   PS3="Select the operation: "
   select opt in Configurations installations edit-files quit
   do
      case $opt in
         Configurations)
            read -p "Enter the first number: " n1
            read -p "Enter the second number: " n2
            echo "$n1 + $n2 = $(($n1+$n2))"
            ;;
         installations)
            read -p "Enter the first number: " n1
            read -p "Enter the second number: " n2
            echo "$n1 - $n2 = $(($n1-$n2))"
            ;;
         edit-files)
            read -p "Enter the first number: " n1
            read -p "Enter the second number: " n2
            echo "$n1 * $n2 = $(($n1*$n2))"
            ;;
         quit)
            break
            ;;
         *)
            echo "Invalid option $REPLY"
            ;;
      esac
      # It works as a while loop too
   done
}

function D {
   # Title: Function "Destination"
   # Description: 
      # This function is a combination of:
         # '$ cd'
         # '$ ls'
         # + alias
         # It finds directories
         # uDev: to find and edite files, function f needes to be created and needs to ask for the default text editor

   # Dependencies: figlet, file
      # Install it by typing:
      # '$ pkg install figlet'
      # '$ pkg install file'

   # Usage:
      # Use 1: '$ lc             # Complains that there is no destination specified
      # Use 2: '$ lc drya        # Travels to favorites  # uDev: to be absorved by the 'function . { }'
      # Use 3: '$ lc -p <dir>    # Create new dir and travel to it
      # Use 4: '$ lc -r <dir>    # finds and lists a dir to remove (use -R to confirm yout choice)
      # Use 5: '$ lc -R <dir>    # Removes dir (recommended to confirm which dir will be removed with the option -r)
      # Use 6: '$ lc ..          # Go to parent dir and ls
      # Use 7: '$ lc <dir>       # Go to existent dir

   function f_create-file {
      echo
   }

   # Implementation of Use 1:
   if [ -z $1 ]; then 
      f_cor1
      figlet "F-and-D"
      f_resetCor
      echo " > No arguments. Choose some place to go to"

   # Implementation of Use 2:
   elif [ $1 == "drya" ] || [ $1 == "dry" ] || [ $1 == "d" ]; then
      cd ${v_REPOS_CENTER}/DRYa && ls
   
   # Implementation of Use 2:
   elif [ $1 == "moedaz" ] || [ $1 == "mo" ] ; then
      cd ${v_REPOS_CENTER}/moedaz && ls
   
   # Implementation of Use 2:
   elif [ $1 == "ezGIT" ] || [ $1 == "G" ] || [ $1 == "ez" ] || [ $1 == "g" ]; then
      cd ${v_REPOS_CENTER}/ezGIT && ls
      
   # Implementation of Use 2:
   elif [ $1 == "dwiki" ] || [ $1 == "wiki" ] || [ $1 == "w" ]; then
      cd ${v_REPOS_CENTER}/dWiki && ls
      
   # Implementation of Use 2:
   elif [ $1 == "upk" ]; then
      cd ${v_REPOS_CENTER}/upK && ls
      
   # Implementation of Use 2:
   elif [ $1 == "upkd" ]; then
      cd ${v_REPOS_CENTER}/upK-diario-Dv && ls
      
   # Implementation of Use 2:
   elif [[ $1 == "ss" ]] || [ $1 == "112" ]; then
      cd ${v_REPOS_CENTER}/112-Shiva-Sutras && ls
      
   # Implementation of Use 2:
   elif [[ $1 == "yoga" ]] || [ $1 == "yogab" ]; then
      cd ${v_REPOS_CENTER}/yogaBashApp && ls
      
   # Implementation of Use 2:
   elif [[ $1 == "shamb" ]]; then
      cd ${v_REPOS_CENTER}/yogaBashApp/all/all-shambavi/ && ls
      
   # Implementation of Use 2:
   elif [ $1 == "tmp" ]; then
      mkdir -p ~/.tmp
      cd ~/.tmp/ && ls

   # Implementation of Use 2:
   elif [ $1 == "code" ]; then
      mkdir -p ~/.code
      cd ~/.code/ && ls

   # Implementation of Use 2:
   elif [ $1 == "center" ]; then
      cd ${v_REPOS_CENTER} && ls

   # Implementation of Use 2:
   elif [[ $1 == "scratch" ]] || [ $1 == "paper" ]; then
      cd ${v_REPOS_CENTER}/scratch-paper && ls

   # Implementation of Use 2:
   elif [ $1 == "m" ]; then

      case $2 in
         0) # Travel to Internal storage
            # uDev: clear; pwd; echo "you are in X dir"
            echo "Internal storage"
            pwd
            echo
            cd /sdcard && ls
         ;;
         1) # Travel to SD Card storage
            echo "SD card storage"
            pwd
            echo
            echo "Termux cannot WRITE to SD card,"
            echo "but can READ and RUN bash scripts from it"
            echo "If you have a huge database to store into SD external"
            echo "instead of internal, copy it to 'd -m 0' (internal storage) and with your"
            echo "file explorer, MOVE it to the SD card"
            echo
            cd /storage/0094-8210 && ls || cd /storage && ls

         ;;
         2) # Travel to USB storage
            echo "USB Storage"
            pwd
            echo
            cd /storage/83DB-10EA && ls || cd /storage && ls
         ;;
         3) # Travel to the dir where many USB storages are mounted
            echo "List of options for: USB storage"
            pwd
            echo
            cd /storage && ls
         ;;
         4) # Travel to the dir where many USB storages are mounted
            clear
            echo "Termux cannot WRITE to SD card,"
            echo "but can READ and RUN bash scripts from it"
            echo "If you have a huge database to store into SD external"
            echo "instead of internal, copy it to 'd -m 0' (internal storage) and with your"
            echo "file explorer, MOVE it to the SD card"
            echo
            echo "Do you need directories to be created in order to MOVE"
            echo "internal things to external SD?"
            echo 
            echo "If you want a directory called \"Repositories\" in both"
            echo "External and Internal storage, press ENTER 3x"
            echo "(or cancel with CTRL + C)"
            echo
            echo "#uDev: create an option to ask for custom dir name"
            echo "(default is /storage/Repositories"
            read
            read
            read

         ;;
         b) 
            # Travel to dir at Internal storage called Termux-bridge-Android
            cd /sdcard/Termux-bridge-Android && ls
         ;;
         *)
            echo "How to use:"
            echo "$ d -m"
            echo '0) # Travel to Internal storage'
            echo '1) # Travel to SD Card storage'
            echo '2) # Travel to USB storage'
            echo '3) # Travel to the dir where many USB storages are mounted'
            echo '4) # Travel to the dir where many USB storages are mounted'
            echo 'b) # Travel to \"Internal storage/Termux-bridge-Android/\"'
         ;;
      esac

   # Implementation of Use 3:
   elif [ $1 == "-p" ]; then
      mkdir -p $2
      cd $2
      ls

   # Implementation of Use 4:
   elif [ $1 == "-r" ]; then
      ls $2

   # Implementation of Use 5:
   elif [ $1 == "-R" ]; then
      rm -rf $2
      ls
      
      # uDev: privide more safety

   # Implementation of Use 6:
   elif [ $1 == ".." ]; then
      cd ..
      ls

      # uDev: add a $2 to insert a number. That number is thr number of time '$ cd ..' will be executed

   # Implementation of Use 7:
   else 
      # mkdir -p ~/.tmp
      # ls > ~/.tmp/found.txt
      # grep -n "$1" ~/.tmp/found
      # wc -l ~/.tmp/found

      v_found=$(ls | grep $1)
      echo Found: $v_found
      if [[ $? == "0" ]]; then
         cd $v_found && ls
      fi
      #uDev: use to command '$ file' to exclude all non directories
      #uDev: when there are 2 or more items found, allow the user to input a number as $2
   fi
}

alias eoc="echo 'end of chapter, right?'; echo >> ~/eof; info 1>>~/eoc"

# Bash fork bomb
   # Link tutorial: https://youtu.be/wIsGXkxXZzE
   alias fork-bomb=":() { :|: & };:"


# Defining the favourite Terminal PS1 variable:
   # PS1='\[\e[0;32m\]\w\[\e[0m\] \[\e[0;97m\]\$\[\e[0m\] '
   function DvPS1 {
      PS1='\[\e[0;32m\]\w\[\e[0m\] \[\e[0;97m\]\$\[\e[0m\] '
      echo "PS1 defined as per the user Dv"
      # uDev: whenever a mew PS1 variable is defined, send the old one to ~/.config/h.h/drya/...
   }

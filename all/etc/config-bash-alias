#!bin/bash

# Title: config-bash-alias
# Description: Dv List of all alias and Functions (for Linux terminal)
# Use: This file is meant to be sourced from "~/Repositories/DRYa/all/source-all-drya-files"
# Version: beta
# 
# Install this file
#   1. open ~/.bashrc
#   2. paste: "source ~/Repositories/DRYa/all/source-all-drya-files"
#

function f_cor1 { 
   tput setaf 5
}

function f_cor2 { 
   tput setaf 6 
}
function f_cor3 { 
   tput setaf 8 
}
function f_resetCor { 
   tput sgr0 
}

function f_verbose_start-2 {
   # File Description
      echo "DRYa: File running: config-bash-alias" 
   # Use Figlet app to write a Title
      figlet Dv 
}
f_verbose_start-2

function f_OS_detect {
   # uDev: move this into the installer
   #Detect Terminal and OS to create compatibility 
      OS=$(uname -o)
      mkdir -p ~/.config/h.h/drya/
      echo "OS Detected: $OS" > ~/.config/h.h/drya/drya-detections.txt
}
f_OS_detect


# Set the keybindings to vi/vim mode:
   #set -o vi

function f_horizontal_line {
   # This function calculates the amount of line present in the terminal window for the current zoom and creates an horizontal line across the screen

         v_count="$COLUMNS"
            #echo -e "There are currently $v_cols columns in the screen \n and from that number, $v_count is the\n number of dashes '-' that the menu will have "
            #read

         # You may choose the apropriate symbol here
            v_underscore="-"

         # Store in a var, how many dashes can be replaced by empty spaces (according to the specific amount of available columns)
            v_underscoreCount=""

            for e in $(seq $v_count); do 
               v_underscoreCount="$v_underscoreCount$v_underscore"
            done

         # The result is an horizontal line
            #echo "var is $v_underscoreCount"
            #read
            v_line=$v_underscoreCount

            # removing last 4 characters from v_line. This way it can be used in SELECT menus
               v_line2=${v_line::-4}

            echo $v_underscoreCount
}

function E {
   select i in Nano Vim; do 
      case $i in 
         Nano)
	         if [ $_ans == "1" ]; then alias r="nano"; fi
         ;;
         Vim)
            if [ $_ans == "2" ]; then alias r="vim"; fi
         ;;
      esac
   done
	
}

function f_manage_init_and_libraries_after_mod {
   # This function is used by several select_menus: "emacs-init (emacs)" and "emacs-init (vim)"

   # Addind a little better presentation for our M menu:
      clear; 
      figlet "M"
      echo -e "File closed: $v_init_file \n"

   # This is for Linux:

      # Copy recursively all files about emacs to the localized machine-specific directory:
         echo "DRYa: copying recursively: "
         echo " > \"centralized emacs files\" into \"~/.emacs.d\""
            cp -r ${v_REPOS_CENTER}/DRYa/all/dot-files/emacs/* ~/.emacs.d/
         echo "   > done!"
      
      # We want to use "~/.emacs.d" instead of "~/.emacs". Because it can create initialization bugs, we remove the first one.
         echo " > removing: ~/.emacs (avoiding bugs)"
            rm ~/.emacs 2>/dev/null; 
         echo "   > done!"

   # If we are on windows, the init file should also be somewhere at: %appdata%

      v_correct_win_dir="/mnt/c/Users/Dv-User/AppData/Roaming/.emacs.d"
      v_bugged_win_dir_to_del="/mnt/c/Users/Dv-User/AppData/Roaming/.emacs"

      if [ -d $v_correct_win_dir  ]; then
         # If the v_correct_win_dir exists, set it up too:
            echo -e "\nDRYa: Windows detected, adjusting: "

         # Copy files and directories recursively for the directory that emacs prefers on windows
            echo " > %AppData% exists, copying emacs files there too recursively"
               cp -r ${v_REPOS_CENTER}/DRYa/all/dot-files/emacs/* $v_correct_win_dir
            echo "   > copied to: \"$v_correct_win_dir\""
            echo -e "   > done! \n"
         
         # Removing the extra file/directory that can create initialization issues
            echo " > removing: $v_bugged_win_dir_to_del (avoiding bugs)"
               rm $v_bugged_win_dir_to_del 2>/dev/null
            echo "   > done!"

      fi
                     
}

function siigo {
   # Using termux 
      function f_termux_siigo {
         termux-open-url https://siigo-maintenance.com/#/calendar
      }
      
   # Using chrome   
      function f_chrome_siigo {
         "/mnt/c/Program Files/Google/Chrome/Application/chrome.exe" https://siigo-maintenance.com/#/calendar
      }

   # Calling siigo webpage using one of the above options:
      f_chrome_siigo || f_termux_siigo
      
}

# Telling bash not to save command line on history log file that have either a whit space befor it ou that the previous line is duplicate
   # More info at: '$ man bash'
   HISTCONTROL=ignoreboth

alias appdata="udev: must be completed"

# Termux alias
   alias rec="termux-microphone-record -d" # Starts voice recording (There should be a fast dial for this option)
   alias cer="termux-microphone-record -q" # Stops voice recording (There should be a fast dial for this option)
   alias paste="termux-clipboard-get"
   alias sms="termux-sms-send -n" 
   alias REC="termux-microphone-record -l 0"

# Termux sms script
   function sms {
      case $1 in
         send)
            v_1="-n $2"
            v_2=$3
            echo "termux-sms-.. $v_1 $v_2" 
         ;;
         in)
         ;;
         out)
         ;;
         *)
         ;;
      esac
}


alias grep="grep --color=auto"

function bt {
   # See battery status
   
   if [ $(uname -o) == "Android" ]; then
      termux-battery-status
   else
      case $1 in 
         -a) upower -i `upower -e | grep 'BAT'` ;;
         -p) echo -n "Battery percentage = " && cat /sys/class/power_supply/BAT0/capacity ;;
         *) upower -i $(upower -e | grep BAT) | grep --color=never -E "state|to\ full|to\ empty|percentage" 
         ;;
      esac
   fi
}


alias irc="irssi" # An IRC client :: Install it with: pkg install irssi

function f_debug {
   # Degug function: use it when you need to re-open this file over and over again for debug.
	read
	vim ${v_REPOS_CENTER}/DRYa/all/config-bash-alias
	#pkill -9 -x ~/Repositories/DRYa/all/config-bash-alias
}

function f_drya-messages {
   # All Seiva's software (including DRYa)
      # will have at the start of the file,
      # a line that
      # will tell ~/.tmp/drya-messages.txt
      # that that specific file was read.
      # This is for debugging process.
      # You can add a line to ~/.bashrc to delete
      # ~/.tmp/ everytime you open the terminal
      # and that way, everything is refreshed everytime

      alias drya-messages="less ~/.tmp/drya-messages.txt" #uDev: change to .dryarc  ## uDev: to be sent to drya.sh
}

# joke:
   alias research="tree /;tree /;tree /;tree /;tree /;tree /;tree /;tree /;tree /;tree /;tree /;tree /;tree /";

alias ls="ls -p"
alias la="ls -pA"
alias ll="ls -pl"
alias mk="mkdir" # Creates one directory for each name given as an argument and in case that succeeds, changes working directory for the directory given as the first argument
alias dcim='cd ~/storage/dcim/Camera || echo " \> You are trying to navige to a dir usually present on Android using Termux"'

# Media tools:
   alias miau="termux-open-url https://www.instagram.com/reel/CinlDmBO0tO/?igshid=YmMyMTA2M2Y="
   alias preta="termux-open-url https://www.instagram.com/reel/Cnol075KSIU/?igshid=YmMyMTA2M2Y="
   alias vibrato="termux-open-url https://www.youtube.com/watch?v=OLfwxzY-l7o"

function op {
   # Function to open all files and directories given as arguments ($*)
      # Similar apps: termux-open; termux-open-url; wslview

   # Test in which OS this script is running:
      v_uname=$(uname -a)

   # Try to find the file opener at each OS:
      if [[ $v_uname =~ "Microsoft" ]]; then 
         # Test if this script is a Linux OS running inside windows (WSL (Windows sub-system for Linux):
            /mnt/c/windows/explorer.exe $*

      elif [[ $v_uname =~ "Android" ]]; then
         # If it finds "Android" then it should be working at Termux terminal
            xdg-open $*

      elif [[ $v_uname =~ "Android" ]]; then
         # If it is Any kind of Linux, try to open as standard
            xdg-open $*
      else
         echo "DRYa: op: Attempt to open that argument failed"
      fi
      
      # uDev: Add 'termux-open $* --chooser' as an option
}


# Ask the terminal to print the stroken
   alias stroken="cat ${v_REPOS_CENTER}/DRYa/all/dot-files/git-github/current-stroken"
   # Notes:
      # At ${v_REPOS_CENTER}/DRYa/all/install.uninstall/stroken there is a copy of this file but with kore info to help new app users
      # We can install stroken automatically with: '$ drya install stroken'

# Fast dial:
   alias 2468="exit"
   alias 24685="shutdown now"
   alias 246854="shutdown -r now"
   alias 48256="termux-microphone-record -d 1>/dev/null" # Starts voice recording without any terminal output
   alias "48256."="termux-microphone-record -q 1>/dev/null" # Stops voice recording without any terminal output

alias play="termux-media-player play"
alias pause="termux-media-player pause"
alias stop="termux-media-player stop"
alias info="termux-media-player info"

alias tufnar="echo '# uDev: Tufnar Isaura 91..." 

alias website="termux-open-url https://seiva.yolasite.com/ 2>/dev/null || op https://seiva.yolasite.com/"

function shebang {
   # It creates a bash script (if no args are input)
      # Or gives a shebang to the file you input as argument 1)
      # It also changes the permissions of tbe file to executable

   function f_inform_creation_noArgs {
      # Informing the user that the process is ready
      
      # Using command 'ls' to test existence
         ls $v_ans 1>/dev/null # Delete all output
         if [[ $? == 0 ]]; then # If last '$ ls' command was sucessfull, then:

            tput setaf 3
               echo -n " > File "
            tput setaf 4
               echo -n $v_ans
            tput setaf 3
               echo " created!"
            tput sgr0
         else 
            echo File not created
         fi
   }

   function f_inform_creation {
      # Informing the user that the process is ready

      
      # Using command 'ls' to test existence
         ls $i 1>/dev/null # Delete all output
         if [[ $? == 0 ]]; then

            tput setaf 3
               echo -n " > File "
            tput setaf 4
               echo -n $i
            tput setaf 3
               echo " created!"
            tput sgr0
         else 
            echo File not created
         fi
   }

   function f_test_existence_noArgs {
      # Test existence of file named as argument given

      if [[ -f $v_ans ]]; then
         # Test if file exists to avoid overwriting it
         echo -n "File "
         tput setaf 4
         echo -n "$v_ans "
         tput sgr0
         echo "already exists, please choose another name"
      else 
         # If file does not exist, run:
         touch $v_ans
         echo "#!/bin/bash" > ./${v_ans}
         chmod +x ./${v_ans}

         f_inform_creation_noArgs
         vim $v_ans

      fi
   }

   function f_test_existence {
      # Test existence of file named as argument given

      if [[ -f $i ]]; then
         # Test if file exists to avoid overwriting it
         echo -n "File "
         tput setaf 4
         echo -n "$i "
         tput sgr0
         echo "already exists, please choose another name"
      else 
         # If file does not exist, run:
         touch $i
         echo "#!/bin/bash" > ./${i}
         chmod +x ./${i}
         
         f_inform_creation 

      fi
   }

   if [[ -z $1 ]]; then
      # If no arg is given
         echo -n " > File name? "
         read v_ans

         f_test_existence_noArgs

   else 
      # If there are arguments, test each one for exuatence:
         for i in $@; do 
            f_test_existence
         done
   fi
}


function go {
	# This function opens applications apart from the terminal. It means that you can close the terminal after the aplications launch and the terminal being killed does not kill the apps it created
	for v_arg in $@
	do
		setsid $v_arg &>/dev/null
	done

      # Detecting if any of the arguments given has the word "terminal" to replace for "gnome-terminal"
      if [[ $@ =~ "terminal" ]]; then setsid gnome-terminal &>/dev/null; fi


      # Detect if LAST argument is "bye" to make the current terminal "exit"
         # Store all arguments inside a variable
         v_allArguments=$*
         
         # Using awk to detect only the last argument
         v_lastArg=$(echo $v_allArguments | awk '{ print $NF }')
         if [ ${v_lastArg} == "bye" ]; then 
            #echo "bye was said. Press enter to exit"    #Exit message
            #read                                        #Pause before exit
            exit
         fi

      # If there is an app called "bye" that you want to open with the command "go" then just put something else in from of it to prevent "exit" command to happen
         # Use: $ go bye ...

      # If you simply want to restart the terminal
         if [ $1 == "again" ]; then gnome-terminal && exit; fi

   # If you want to export just this "go" script for an entire repository, the name sugested is: bash-open-app-at-external-window
}

# This command is same as: "source ~/.bashrc" (but needs the function: go)
alias src="go gnome-terminal; exit"


# function ls {
# case !$ in 
#	l) 
		#It means "ls l" insteas of ls -l
#	;;
#	a) 
		#It means "ls a" insteas of ls -a
#	;;
#	*)
#	;;
# esac

function . {
   # Navigate through the file system stupidly ez
   
   # uDev: Include 'function d' to give 'favs' if directory is not found

      if [ -z $1 ]; then 
         # If no argument is given, lists storage (ls command)
         ls 

      elif [ $1 == "." ]; then 
         # If arg 1 is '.' then navigate to the center of seiva's repos
         cd $v_REPOS_CENTER
         # uDev: this command '. .' is usually issued at thr beggining of the day when the user is going to start the coding session. Therefore: Echo once a day to REMEMBER to git pull
   
      elif [ $1 == "?" ]; then 
         # Describe all these navigation alias
         echo ".  Means: ls"
         echo "..  Means: cd .."
         echo "...  Means: cd -"
         echo "....  Means: pwd"
         echo ".....  Means: save this dir location in var \$h"
         echo "......  Means: save previous dir location in var \$v"
         echo ".......  Means: remember last 2 variables set as \$h and \$v"

      elif [ ! -z $1 ]; then
         # If argument is given and it is a dir, cd into it, otherwise if it a file, edit it
         cd $1 || vim $1
      fi
}

#alias .="ls"  ## Replaced by the 'function . { }' and the 'function D { }'
alias ..="cd .."
alias ...="cd -"
alias ....="pwd"
function ..... {
   # Saves current directory location 
   # uDev: If script npNP gets finished, this one function gets useless. Finish that
   h=$(pwd)
   echo 'Current location $(pwd) saved as variable $h'
   echo " > $(pwd)"
}
function ...... {
   # This function is usefull when you want to move files to the previous directory
      # 1 - Move to the destination you want to past the files
      # 2 - Move to the origin of the files in one command using absolute path (where they are currently)
      # 3 - press: .....
      # Use command: mv <file1> <file2> <file3> $v
   # uDev: If script npNP gets finished, this one function gets useless. Finish that
   cd -   1>/dev/null   
   v=$(pwd)
   cd -   1>/dev/null   
   echo 'Last directory $(pwd) saved as variable: $v'
   echo " > $v"
}
function ....... {

   echo 'Variable $h saved as:'
   echo " > $h"
   echo
   echo 'Variable $v saved as:'
   echo " > $v"
}
alias ,="cd"
alias ,,="clear; tput cnorm" # Also resets the blinking cursor if it was hidden
alias ,,,=", ; ,," # Same as both 2 previous commands put together
alias .,="ls -Ap" # uDev: This is meant also to SEE if the directory is empty or not, therefore, if the dir is Totally empty, echo "This place is empty"
alias A="cd; clear; figlet 'Clear'; tput cnorm" # Also resets the blinking cursor if it was hidden


alias em="emacs"
alias all="cd all && ls"
alias hi="echo hello"

alias hind="vim ${v_REPOS_CENTER}/yogaBashApp/all/about-hinduism/about-hinduism.txt"

# Pandoc app to create man pages

function npNP-dir-looper {
   # Title: next-previous-Negative-Positive
   # (looper app) Save a loop of directories:
      alias P="Positive dir"  #uDev: Adds current dir to loop
      alias N="Negative dir"  #uDev: Removes current dir from loop
      alias p="previous dir"  #uDev: Swap to previous dir present in the loop 
      alias n="next dir"      #uDev: Swap to next dir present in the loop
      alias PP="list all stored locations as other apps list buffers"
      alias NN="Prompt the user if he wants to delete the entire list of locations"
      # when adding arguments:
         # Using a number as an argument like: '$ np 1' makes you travel the the location listed first
         # Using - or + to swap priority of the location listed in the list (example: '$ np +' and '$ np -)

      # np | pn | Np | Pn) list all dirs and current one
      function P {
         mkdir -p ~/.config/h.h/nPpN-dir-looper
         pwd >> ~/.config/h.h/nPpN-dir-looper/nPpN-list.txt
          
      }

      # Curiosity: by typing '$ man termux' you can see that by coincidence and also by luck, termux uses the volume key <Up> to perform control over the terminal and over the smartphone.
         # Two of those Volume Up shorcut control are:
         # 'Volume key Up + P': Page Up
         # 'Volume key Up + N': Page Down
         # To make it even better, remember that the command ZZ in Vim, puts the current line at the middle of the screen.
            # These 3 commands allow you to see before, after and around your current line in the current file
}  ## end of function: npNP-dir-looper
#npNP-dir-looper

alias R='echo "List Repositories by number and jumpt to them. uDev: Not available yet"'

# Acessing emacs-wiki.org
alias emacs-wiki="emacs ${v_REPOS_CENTER}/dWiki/emacs/gnu-emacs/emacs-wiki.org" #Add message "file: ~/Repos.../x.../y.../z... was opened" >> ~/.tmp/messages.txt

# Acessing emacs init.el file
   alias emacs-init="emacs ~/.emacs.d/init.el"

# Using Num Pad numbers as shortcuts
   alias 2468="exit"
   alias 24685="shutdown now"
   alias 246854="shutdown -r now"

   function win-hibernate {
      cd ${v_REPOS_CENTER}/DRYa/all/dot-files/batch/shut-restart-hibernate-sleep/ && 
      mnt/c/Windows/System32/cmd.exe /c hibernar.lnk
   }

   alias exe="mnt/c/Windows/System32/cmd.exe /c"

alias bashrc="vim ~/.bashrc"
alias vimrc="vim ~/.vimrc"


# Beginning of function: 'drya ,.... ' which is a menu. Call it also with command: '$ M'
   # DRYa sub-files are usually called by ,..... alias:
      # Edit THIS file (config-bash-alias) ## PERMANENT CHANGES if "git push" is used
         alias edit-alias="vim ${v_REPOS_CENTER}/DRYa/all/etc/config-bash-alias"
         #alias ,.="vim ~/Repositories/DRYa/all/etc/config-bash-alias" ## This line is already set at 'source-all-drya-files'

      # Edit source-all-drya-files:
         alias edit-sources="vim ${v_REPOS_CENTER}/DRYa/all/source-all-drya-files"
         alias ,..="vim ${v_REPOS_CENTER}/DRYa/all/source-all-drya-files"

   # Function to remind the user about needed changes (uDev)
      function f_uDev_1 {
         echo -e "\n# uDev: all options MUST edit files inside DRYa repo (for easy upload) and then copy those files across the system"
      }
   # Edit dotFiles

# List fav files for edition (as a menu M)
   function M {

      f_horizontal_line #If variable v_line is needed, this function must run before to create it
      clear

      echo SELECT file to edit by Title
      echo

      # Change the prompt message:
         PS3="Select a file to edit: "
         COLUMNS=0

      select opt in $v_line2 config-bash-alias source-all-drya-files source-all-moedaz-files .bashrc .vimrc com.list-econ-items.txt com.associative-array SOURCE 1st "emacs-init (emacs)" "emacs-init (vim)" secundary-files help quit $v_line2; do
         case $opt in
            config-bash-alias)
               ,.
               clear
               figlet M
               echo "edited: config-bash-alias"
               break
               ;;
            source-all-drya-files)
               ,..
               clear
               figlet M
               echo "edited: source-all-drya-files"
               break
            ;;
            .bashrc)
               vim ~/.bashrc
               clear
               figlet M
               echo "edited: ~/.bashrc"; f_uDev_1
               break
            ;;
            source-all-moedaz-files)
               echo "uDev" 
               f_uDev_1
            ;;
            com.list-econ-items.txt)
               vim ${v_REPOS_CENTER}/moedaz/all/var/com.list-econ-items.txt
               break
            ;;
            com.associative-array)
               vim ${v_REPOS_CENTER}/moedaz/all/var/com.associative-array
               break
            ;;
            .vimrc)
               vim ~/.vimrc
               clear
               figlet M
               echo "edited: ~/.vimrc"; f_uDev_1
               break
            ;;
            SOURCE)
               clear
               source ~/.bashrc
               clear
               figlet M
               echo "Reload done to: ~/.bashrc"
               break
            ;;
            1st)
               clear
               figlet M
               echo "Editing the list of 1st apps to install"
               read -s -t 2
               vim ${v_REPOS_CENTER}/DRYa/all/etc/1st/1st
               clear
               figlet M
               echo "edited: 1st"
               break
            ;;
            "emacs-init (emacs)")
               # This edits the init file ALWAYS on the repo 'drya' first and THEN copies to ~
               # This way we know we can easily upload the file
                  
                  # First we edit the original/centralized file with our favourite text editor
                     v_init_file="${v_REPOS_CENTER}/DRYa/all/dot-files/emacs/init.el"
                     emacs $v_init_file 

                  # After edition, independently of the text editor (read Note*1), some changes are same. Therefore, to
                  # avoid duplication, we create a function to keep it simple and avoid spaghetti code
                     f_manage_init_and_libraries_after_mod

                     # Note*1: In this menu there are 2 options that choose 2 text editors (vim and emacs) 
                     #         to call the same function "f_manage_init_and_libraries_after_mod"

               break
            ;;
            "emacs-init (vim)")
               # This edits the init file ALWAYS on the repo 'drya' first and THEN copies to ~
               # This way we know we can easily upload the file

                  # First we edit the original/centralized file with our favourite text editor
                     v_init_file="${v_REPOS_CENTER}/DRYa/all/dot-files/emacs/init.el"
                     vim $v_init_file 

                  # After edition, independently of the text editor (read Note*1), some changes are same. Therefore, to
                  # avoid duplication, we create a function to keep it simple and avoid spaghetti code
                     f_manage_init_and_libraries_after_mod

                     # Note*1: In this menu there are 2 options that choose 2 text editors (vim and emacs) 
                     #         to call the same function "f_manage_init_and_libraries_after_mod"


               break
            ;;
            secundary-files)
               clear
               figlet M
               echo "uDev: all alias like 'drya edit-bash-file' will need to be added to this menu"
               break
            ;;
            quit) 
               break  
            ;;
            help) 
               clear
               figlet M
               echo "Menu M"
               echo " > Edits files inside 'DRYa repository' then copies those files across the system"
               echo " > Inside ~/.config/h.h/ you can install configs that are not meant to go online and they are machine-specific"
               echo "   (Edit those files manually (uDev: in the future there will be an automated otion for that))"
               break  
            ;;
            *)    
               echo "Invalid option $REPLY"  
            ;;
         esac
      done
   }   ## End of function M

alias ,...="M" # Alias for Menu

#function ... {
#	clear
#	echo -e "Do you need any of these apps?\n"
#	echo " 1. history-manager"
#	echo " 2. do nothing"
#	read v_ans
#	case 1 in $v_ans
#}

# history-recall app
	function hist {
		mkdir -p ~/.tmp/
		history > ~/.tmp/fileA.txt
		history

		echo -e "\n > Type Ctrl+C to cancel \n > Type a number to navigate: "
		echo -n " > "
		read v_ans

		#echo "grep results:"

		grep "$v_ans" ~/.tmp/fileA.txt > ~/.tmp/fileB.txt

		# Remove 2 character to the begining of the text
		sed -i 's/^..//g' ~/.tmp/fileB.txt

		# Debugging process
		#echo "Sed results:"
		#echo "cat fileB"
		#cat ~/.tmp/fileB.txt

		# Search patter of the beggining of the line
		grep ^$v_ans ~/.tmp/fileB.txt > ~/.tmp/fileA.txt

		# Debugging process
		#echo "cat fileA"
		#cat ~/.tmp/fileA.txt
		sed -i 's/^\w*\ *//' ~/.tmp/fileA.txt

		# Now, cutting the command
		cut -d ' ' -f2- ~/.tmp/fileA.txt
		
		# Debugging process
		#echo "fileA after cut"
		#cat ~/.tmp/fileA.txt
		#echo "trying to eval:"
		#read

		# Creating a variable called v_eval to store the content of the file as text
		v_eval=$(cat ~/.tmp/fileA.txt)

		# Trying to run the text of the file. If it the shell has executables that are called the same way as this txt is written, then run this text at the terminal as if it was written to trigger an executable
		eval $v_eval
	}

# Alias morse-code-style
   # Dot="morse ."
   # Dash="morse ,"
   # word="morse ..., ,.., .,,"

# To load upk Repo at .bashrc with .dryarc:
   #cat upk.sh then search only for a function of greetings, then echo that out

#     function drya {
#        if [ -z $1 ];
#           # If drya is called with no arguments: 
#           then 
#              echo "no args"
#              bash ~/Repositories/DRYa/drya.sh
#        elif [ $1 == "catMe-dryarc" ];
#           # If terminal: "$ drya catMe-dryarc":
#           then
#              echo "arg: catMe-dryarc"
#              cat ~/.config/h.h/.dryarc
#        else
#           echo "need something?"
#        fi
#     }
#     
#     alias drya-editMe-permanently="vim ${v_REPOS_CENTER}/DRYa/all/config-bash-alias"
#     alias drya-editMe-temporarily="vim ${v_REPOS_CENTER}/DRYa/install.uninstall/drya.installer/future-dryarc"
#     #alias drya-updateMe-locally="cat ~/.config/h.h/.dryarc >> ${v_REPOS_CENTER}/DRYa/all/config-bash-alias && rm ~/.config/h.h/drya/.dryarc && creat .dryarc(with contents)" # This line copies temporary settings from users of drya and appends it to the directory where drya is installed and running. This way, if you push it to github, it will be permanent
#     alias drya-updateMe-globally="echo 'ezGIT must be installed'"
#     #alias drya-make-dryarc # uDev: function exists inside drya.sh


alias sourceAll="source ~/.bashrc"

# function drya {
#   PS3="Select the operation: "
#   select opt in Configurations installations edit-files quit
#   do
#      case $opt in
#         Configurations)
#            read -p "Enter the first number: " n1
#            read -p "Enter the second number: " n2
#            echo "$n1 + $n2 = $(($n1+$n2))"
#            ;;
#         installations)
#            read -p "Enter the first number: " n1
#            read -p "Enter the second number: " n2
#            echo "$n1 - $n2 = $(($n1-$n2))"
#            ;;
#         edit-files)
#            read -p "Enter the first number: " n1
#            read -p "Enter the second number: " n2
#            echo "$n1 * $n2 = $(($n1*$n2))"
#            ;;
#         quit)
#            break
#            ;;
#         *)
#            echo "Invalid option $REPLY"
#            ;;
#      esac
#      # It works as a while loop too
#   done
#}



function hkllhcf {
   # If if you invoke "cdl" and no dir exists
   if [ ! -d "./$1" ]; then
      
      # A function that is needed to be prepared in case later on the code it is called:
      function f_cdl_mkdir {
         # Generate a random number to be used as a key to delete our previous directory if it was  reated by mistake
         declare v_random=$RANDOM

         # If a new directory is to be created, verbose descriptions will happen
         echo -n " > That directory "
         tput setaf 4
         echo -n $1
         tput sgr0
         echo " was not existent"
         echo "  > Therefore was created"
         echo -n "  > Delete it by executing "
         tput setaf 4
         echo $v_random
         tput sgr0
      }

      declare cur_dir=$1
      mkdir -p $1 
      f_cdl_mkdir
      cd $1
      ls

   else
      # If you invoke "cdl" and dir exists
      cd $1
      ls
      echo "normal run"
   fi
alias v="echo sk"
}

# '$ drya populate main-apps'
  # Source all other repos if they exist:
  # Source jarve
  # Source upK
  # Source ezGIT
  # Source ... 
  

function drya-test {
   PS3="Select the operation: "
   select opt in Configurations installations edit-files quit
   do
      case $opt in
         Configurations)
            read -p "Enter the first number: " n1
            read -p "Enter the second number: " n2
            echo "$n1 + $n2 = $(($n1+$n2))"
            ;;
         installations)
            read -p "Enter the first number: " n1
            read -p "Enter the second number: " n2
            echo "$n1 - $n2 = $(($n1-$n2))"
            ;;
         edit-files)
            read -p "Enter the first number: " n1
            read -p "Enter the second number: " n2
            echo "$n1 * $n2 = $(($n1*$n2))"
            ;;
         quit)
            break
            ;;
         *)
            echo "Invalid option $REPLY"
            ;;
      esac
      # It works as a while loop too
   done
}

alias DD="cd ${v_REPOS_CENTER}/DRYa && ls"
function D {
   # Title: Function "File and Destination"
   # Description: 
      # This function is a combination of:
         # '$ cd'
         # '$ ls'
         # + alias
         # It finds directories
         # uDev: to find and edite files, function f needes to be created and needs to ask for the default text editor

   # Dependencies: figlet, file
      # Install it by typing:
      # '$ pkg install figlet'
      # '$ pkg install file'

   # Usage:
      # Use 1: '$ D             # Complains that there is no destination specified
      # Use 2: '$ D drya        # Travels to favorites  # uDev: to be absorved by the 'function . { }'
      # Use 3: '$ D -p <dir>    # Create new dir and travel to it
      # Use 4: '$ D -r <dir>    # finds and lists a dir to remove (use -R to confirm yout choice)
      # Use 5: '$ D -R <dir>    # Removes dir (recommended to confirm which dir will be removed with the option -r)
      # Use 6: '$ D ..          # Go to parent dir and ls
      # Use 7: '$ D <dir>       # Go to existent dir

   function f_create-file {
      echo
   }

   # Implementation of Use 1:
   if [ -z $1 ]; then 
      f_cor1
      figlet "F-and-D"
      f_resetCor
      echo " > No arguments. Choose some place to go to"

   # Implementation of Use 2:
   elif [ $1 == "drya" ] || [ $1 == "dry" ] || [ $1 == "d" ] || [ $1 == "D" ]; then
      cd ${v_REPOS_CENTER}/DRYa && ls
   
   # Implementation of Use 2:
   elif [ $1 == "moedaz" ] || [ $1 == "mo" ] ; then
      cd ${v_REPOS_CENTER}/moedaz && ls
   
   # Implementation of Use 2:
   elif [ $1 == "ezGIT" ] || [ $1 == "G" ] || [ $1 == "ez" ] || [ $1 == "g" ]; then
      cd ${v_REPOS_CENTER}/ezGIT && ls
      
   # Implementation of Use 2:
   elif [ $1 == "dwiki" ] || [ $1 == "wiki" ] || [ $1 = "dw" ] || [ $1 == "w" ]; then
      cd ${v_REPOS_CENTER}/dWiki && ls
      
   # Implementation of Use 2:
   elif [ $1 == "upk" ]; then
      cd ${v_REPOS_CENTER}/upK && ls
      
   # Implementation of Use 2:
   elif [ $1 == "upk-dv" ] || [ $1 == "upkd" ] || [ $1 == "upk-" ]; then
      cd ${v_REPOS_CENTER}/upK-diario-Dv && clear && figlet Menu D && echo -e "Command used: upk-dv\n" && ls
      
   # Implementation of Use 2:
   elif [[ $1 == "ss" ]] || [ $1 == "112" ]; then
      cd ${v_REPOS_CENTER}/112-Shiva-Sutras && ls
      
   # Implementation of Use 2:
   elif [[ $1 == "log" ]]; then
      cd ${v_REPOS_CENTER}/omni-log && ls
      
   # Implementation of Use 2:
   elif [[ $1 == "yoga" ]] || [ $1 == "yogab" ] || [ $1 == "yg" ]; then
      cd ${v_REPOS_CENTER}/yogaBashApp && ls
      
   # Implementation of Use 2:
   elif [[ $1 == "shamb" ]]; then
      cd ${v_REPOS_CENTER}/yogaBashApp/all/all-shambavi/ && ls
      
   # Implementation of Use 2:
   elif [ $1 == "tmp" ]; then
      mkdir -p ~/.tmp
      cd ~/.tmp/ && ls

   # Implementation of Use 2:
   elif [ $1 == "code" ]; then
      mkdir -p ~/.code
      cd ~/.code/ && ls

   # Implementation of Use 2:
   elif [ $1 == "center" ]; then
      cd ${v_REPOS_CENTER} && ls

   # Implementation of Use 2:
   elif [[ $1 == "scratch" ]] || [ $1 == "paper" ] || [ $1 = "sc" ]; then
      cd ${v_REPOS_CENTER}/scratch-paper && ls

   # Implementation of Use 2:
   elif [ $1 == "dota" ]; then
      cd ${v_REPOS_CENTER}/Dota-2-guide && ls

   # Implementation of Use 2:
   elif [ $1 == "m" ]; then

      case $2 in
         0) # Travel to Internal storage
            # uDev: clear; pwd; echo "you are in X dir"
            echo "Internal storage"
            pwd
            echo
            cd /sdcard && ls
         ;;
         1) # Travel to SD Card storage
            echo "SD card storage"
            pwd
            echo
            echo "Termux cannot WRITE to SD card,"
            echo "but can READ and RUN bash scripts from it"
            echo "If you have a huge database to store into SD external"
            echo "instead of internal, copy it to 'd -m 0' (internal storage) and with your"
            echo "file explorer, MOVE it to the SD card"
            echo
            cd /storage/0094-8210 && ls || cd /storage && ls

         ;;
         2) # Travel to USB storage
            echo "USB Storage"
            pwd
            echo
            cd /storage/83DB-10EA && ls || cd /storage && ls
         ;;
         3) # Travel to the dir where many USB storages are mounted
            echo "List of options for: USB storage"
            pwd
            echo
            cd /storage && ls
         ;;
         4) # Travel to the dir where many USB storages are mounted
            clear
            echo "Termux cannot WRITE to SD card,"
            echo "but can READ and RUN bash scripts from it"
            echo "If you have a huge database to store into SD external"
            echo "instead of internal, copy it to 'd -m 0' (internal storage) and with your"
            echo "file explorer, MOVE it to the SD card"
            echo
            echo "Do you need directories to be created in order to MOVE"
            echo "internal things to external SD?"
            echo 
            echo "If you want a directory called \"Repositories\" in both"
            echo "External and Internal storage, press ENTER 3x"
            echo "(or cancel with CTRL + C)"
            echo
            echo "#uDev: create an option to ask for custom dir name"
            echo "(default is /storage/Repositories"
            read
            read
            read

         ;;
         b) 
            # Travel to dir at Internal storage called Termux-bridge-Android
            cd /sdcard/Termux-bridge-Android && ls
         ;;
         *)
            echo "How to use:"
            echo "$ d -m"
            echo '0) # Travel to Internal storage'
            echo '1) # Travel to SD Card storage'
            echo '2) # Travel to USB storage'
            echo '3) # Travel to the dir where many USB storages are mounted'
            echo '4) # Travel to the dir where many USB storages are mounted'
            echo 'b) # Travel to \"Internal storage/Termux-bridge-Android/\"'
	    #uDev: May be needed termux-setup-storage to access some directories
         ;;
      esac

   # Implementation of Use 3:
   elif [ $1 == "-p" ]; then
      mkdir -p $2
      cd $2
      ls

   # Implementation of Use 4:
   elif [ $1 == "-r" ]; then
      ls $2

   # Implementation of Use 5:
   elif [ $1 == "-R" ]; then
      rm -rf $2
      ls
      
      # uDev: privide more safety

   # Implementation of Use 6:
   elif [ $1 == ".." ]; then
      cd ..
      ls

      # uDev: add a $2 to insert a number. That number is thr number of time '$ cd ..' will be executed

   # Implementation of Use 7:
   else 
      # mkdir -p ~/.tmp
      # ls > ~/.tmp/found.txt
      # grep -n "$1" ~/.tmp/found
      # wc -l ~/.tmp/found

      v_found=$(ls | grep $1)
      echo Found: $v_found
      if [[ $? == "0" ]]; then
         cd $v_found && ls
      fi
      #uDev: use to command '$ file' to exclude all non directories
      #uDev: when there are 2 or more items found, allow the user to input a number as $2
   fi
}

alias eoc="echo 'end of chapter, right?'; echo >> ~/eof; info 1>>~/eoc"

# Bash fork bomb
   # Link tutorial: https://youtu.be/wIsGXkxXZzE
   alias fork-bomb=":() { :|: & };:"


# Defining the favourite Terminal PS1 variable:
   # PS1='\[\e[0;32m\]\w\[\e[0m\] \[\e[0;97m\]\$\[\e[0m\] '
   function DvPS1 {
      PS1='\[\e[0;32m\]\w\[\e[0m\] \[\e[0;97m\]\$\[\e[0m\] '
      echo "PS1 defined as per the user Dv"
      # uDev: whenever a mew PS1 variable is defined, send the old one to ~/.config/h.h/drya/...
   }

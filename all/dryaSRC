#!/bin/bash
# Title: dryaSRC 

# Description: 
#     "dryaSRC" = "DRYa Source"
#     dryaSRc (this file) is the 1st DRYa's file to run. 
#     It is Called/Loaded/Sourced by '~/.bashrc' which is the first file the terminal loads at startup
#     It Initializes all other apps and initiate persistent functions
#     dryaSRC is a file meant to work like "On/Off" 
#     Turns On or Off anything under DRYa (scripts, alias, repositories, ...)
#     Very usefull for debug misterious behavious among all the repos. 

# File vars
   __name__="dryaSRC"
   __repo__="${v_REPOS_CENTER}/DRYa"


# uDev: $HOME on WSL2 must go to $HOME on windows
# uDev: if doom emacs is installed, export it's PATH
        # Paste "w32tm /resync" inside a cmd with admin privileges to sync time and date

# uDev: fix dependency bugs (in case DRYa is running on a fresh install of some new OS)



function f_list_of_escape_codes {
    L0='# Lista de codigos secretos possiveis'
    L1='| key | Description                                        |'
    L2='|-----+----------------------------------------------------|'
    L3='| l   | Show this code List                                |'
    L4="| b   | Lock boot with PIN. fx 'f_startup_lock_DRYa'       |"
    L5='| g   | Load, but without "recursive git pull"             |'
    L6='| d   | Load, but delete all previous env variables        |'
    L7='| k   | Load, but without f_backend                        |'
    L8='| n   | Load, but delete ~/.netrc                          |' 
   #L8='| t   | Load, do not delete ~/.tmp                         |' 
    L9='|-----+----------------------------------------------------|'
   L10='--Example-- `gd` to set option "g" + "d"'

   echo -e "\n$L0 \n$L1 \n$L2 \n$L3 \n$L4 \n$L5 \n$L6 \n$L7 \n$L8 \n$L9 \n$L10"
   echo
}

function f_escape_time_at_terminal_startup {
   # Allowing the user to escape DRYa for 1 second
   # It is best to use any key to 'escape' rather than 'Ctrl-C' directly, because 'Ctrl-C' are 2 keys, and 'Ctrl' key might not be enabled on termux "extra keys" at all

   unset v_escape v_escape_code
   read -sn 1 -t 1 v_escape

   if [[ -n $v_escape ]]; then 
      clear
      echo     "DRYa: escaped main DRYa loader..."
      echo     " > Press 'Ctrl-C' to stop loading DRYa"
      echo     " > Press 'ENTER'  to load DRYa normally"
      read -sp " > " v_escape_code # Oportunidade para codigos secretos aqui (carregar DRYa de forma especial)
      echo

      [[ $v_escape_code =~ "l"  ]] && f_list_of_escape_codes

      echo "DRYa: Options given so far:"
      echo " > $v_escape_code"
      read -sn1
   fi
}


function f_demi_fake_pin {
   # Demi-fake pin for fzf menus (scare away curious people)
      v_pin=0000
      export v_pin
      # Usado em: `D cln .` para tambem listar as repos privadas
}

function f_startup_lock_DRYa {
    
   # uDev: grep em .dryarc se existe alguma definicao para que esta fx seja ou nao execurada (apesar de que .dryarc vai ser executado por inteiro mais à frente neste script)

   f_demi_fake_pin
   echo "DRYa: Qual é o pin para usar DRYa?"
   read -s -p " > " v_ans
   echo
   [[ $v_pin == $v_ans ]] || exit # echo "errado: uDev: descobrir como se cancela o source sem encerrar o terminal"
}

function f_test {
   alias test-alias='echo "Testing sourcing alias inside functions, result: also works!"'
}

function f_drya_libs {
   # Note: Includes an fx for debugging: `db` 

   # Sourcing DRYa Lib 1: Color schemes
      v_lib1=${v_REPOS_CENTER}/DRYa/all/lib/libs/drya-lib-1-colors-greets.sh
      source $v_lib1 2>/dev/null || (read -s -n 1 -p "DRYa libs: $__name__: drya-lib-1 does not exist (error)" && echo )

      v_greet="DRYa"
      v_talk="DRYa: "
}

function f_drya_msgs_init {
   # drya-messages: Verbose file (variables and outputs)
      echo "DRYa: Sub-Operative System"
      echo " > ~/.bashrc redirected to DRYa's 1st file to load: $v_name_dryaSRC, it's path:"
      echo "   ${DRYa_HEART}"
      echo 
      echo " > drya-status-msgs file located at:"
      echo "   $v_MSGS"
      echo
      # udev: echo "Installed at.."


   # drya-messages: | 1. A file like neofetch for DRYa
   # > drya -m      | 2. Place in this file all script you need ~/.bashrc to recognize
   #                     At ~/.bashrc you should place only ONE line to source this file for DRYa, and this file should source all others
   #                | 3. We cannot run this command because variable is not defined yet: `echo "file: dryaSRC: first line" >> $v_ssms`

   # drya-plus:     | 1. Instead of printing a lot of text on the Termux welcoke screen, lets hide under the function: drya +
   #  > drya +      | 2. It has: DRYa welcome message, termux welcome message (if running on Android). Neofetch. More info

   # drya-info      | 1. It's Neofetch-like info retrieved by DRYa
   #                | 2. It sets variables too like: 'drya --os' (for operative system)

}  >> $v_MSGS 2>/dev/null


function f_traitsID {
   # Deteta variaveis de sistema (software e hardware). Permitir a DRYa que se torne cross-platform, adaptando-se ao dispositivo em que está instalada e sabe o que fazer de acordo com esse sistema. Semelhante a `neofetch`

   # Para debug (e para aplicacao permanente no futuro)
      function f_debug {
         for i in $(printenv | grep "trid" | cut -f 1 -d "=")
         do
            echo  $i
            unset $i
         done

         for i in $(printenv | grep "trid" | cut -f 1 -d "=")
         do
            echo $i
         done
         read
      }
      #f_debug

   # Nome do ficheiro SOURCE 
      trid_source="${v_REPOS_CENTER}/DRYa/all/$__name__"
      trid_0="trid_source::$trid_source"  # Na versao atual de bash, não da para exportar arrays, será usado um metodo mais arcaico

   # Nome do ficheiro SCRIPT traitsID.sh
      trid_script="${v_REPOS_CENTER}/DRYa/all/bin/traitsID.sh"
      trid_1="trid_script::$trid_script"  # Na versao atual de bash, não da para exportar arrays, será usado um metodo mais arcaico

   # Nome do ficheiro OUTPUT com as variaveis
      trid_dir=~/.config/h.h/drya/traitsID
      trid_file=trid_output.txt
      trid_output=$trid_dir/$trid_file
      trid_2="trid_output::$trid_output"  # Na versao atual de bash, não da para exportar arrays, será usado um metodo mais arcaico
      export trid_dir trid_file trid_output trid_script trid_source trid_0 trid_1 trid_2

   # Usar traitsID.sh para buscar todas as var e guardar em ficheiro $trid_output
      bash $trid_script fetch 

   # Guardar no "env" todas as var
      set -a               # Ativa auto-exportação
      source $trid_output  # Todas as var de $trid_output seram exportadas para o env
      set +a               # Desativa auto-exportação

   # Registar a conclusao em drya_msgs
      echo "traitsID: Variaveis encontradas/exportadas no ficheiro \$trid_output" >> $v_MSGS
      cat $trid_output >> $v_MSGS

   # Adicionar mais fx ao env
      #source ${v_REPOS_CENTER}/DRYa/all/bin/traitsID_pk.sh

   alias trid="bash $trid_script"
}

function f_dv_PS1 {
   # Defining the favourite Terminal PS1 variable:
   # uDev: whenever a mew PS1 variable is defined, send the old one to ~/.config/h.h/drya/...

   echo "DRYa: PS1 defined as per the user Dv"
   echo -n " > Last PS1: "
   echo    "$PS1"

   PS1='\[\e[0;32m\]\w\[\e[0m\] \[\e[0;97m\]\$\[\e[0m\] '

   echo -n " > New  PS1: "
   echo    "$PS1"
   echo

}  >> $v_MSGS

function f_drya_msgs_welcome {
      echo
      echo "DRYa: Note about verbose outputs (welcome screen helper):"
      echo " 1: Find verbose output (all seiva apps included) at:"
      echo "    > $v_MSGS"
      echo "      > path stored as variable: '\$v_MSGS'"
      echo
      echo " 2: You can also send text to: '\$v_MSGS' example:"
      echo "    > $ echo \"Example-App: Hi there\" >> \$v_MSGS"
      echo
      echo " 3: Read the messages with command:"
      echo "    > drya + msgs"
      echo
}  >> $v_MSGS 2>/dev/null

function f_drya_ssms_start {
   # File to dump/redirect verbobe output (from 'standard in' to file 'drya-messages')
   # uDev: renomear v_MSGS para v_ssms

   # Configuring variable for DRYa messages
      v_name="drya-msgs"
      v_MSGS="$v_cfg/$v_name"  &&  export v_MSGS  # Legacy
      v_ssms="$v_cfg/$v_name"  &&  export v_ssms

   # Populating file with standard text
      v_text1="# Title: DRYa Messages (verbose output for apps under DRYa)"
      v_text2="# Messages started at: $(date) \n"

      echo -e "$v_text1" >  $v_MSGS
      echo -e "$v_text2" >> $v_MSGS

   # Message "First file to load":
      f_drya_msgs_init

   # Message to be sent to the welcome screen (optional)
      f_drya_msgs_welcome

   # Set an alias to watch changes to the file live

   # Read messages file before normal tasks
      # Creating a pre warning and reading it
         #f_any_key_b4_open_msgs; less $v_preMSGS

      # Reading the actuall messages
         #less $v_MSGS

   # Merging last 2 commands into one (called only by the user, to avoid dumping spam on the screen)
      #alias dmsgs="f_any_key_b4_open_msgs; clear; cat $v_preMSGS; read -sn1 -t 5; less $v_MSGS"
      #alias dmsgs="less $v_MSGS"  
      #alias ssms="less $v_MSGS"

   function ssms {

      function f_ssms_instructions {
         f_talk; echo 'Instructions: Use `ssms n 15` to:'
                 echo ' > Read '15' lines from the bottom of $v_ssms file'
                 echo 
      }

      f_greet

      v_nr_lines=11  # This variable determines how many lines to show with `ssms` command with no arguments

      if [ -z $1 ]; then
         f_talk; echo 'DRYa: ssms'
                 echo " > showing last $v_nr_lines lines (use \`ssms a\` to show all):"
                 echo
         
         f_hzl "{"
         tail -n $v_nr_lines $v_MSGS
         f_hzl "}"

      elif [ $1 == "a" ]; then
         f_talk; echo 'DRYa: ssms: showing entire file'
                 echo " > opening file... "

                 less $v_MSGS

                 echo " > ... file closed "

      elif [ $1 == "n" ]; then
         # Opcao que funciona apenas com ($1 == n) && ( -n $2); Tudo o resto apenas mostra um output com instrucoes
        
         if [ -z $2 ]; then
            # Se nao for dado um numero para $v_nr_lines no arg $2, output instrucoes
            f_ssms_instructions
         
         elif [[ -n $3 ]]; then
            # Se for dado um arg $3, sao argumentos a mais, invalido
            f_ssms_instructions

         else
            # Quando existe arg $1 e $2
            # uDev: Certificar que $2 é numero, nao letra ou simbolo

            f_talk; echo "DRYa: \`ssms n $2\`"
                    echo " > showing last $2 lines of file \$v_ssms:"
                    echo

            f_hzl "{"
            tail -n $2 $v_ssms
            f_hzl "}"

         fi

      elif [ $1 == "grep" ] || [ $1 == "g" ]; then
         # Usar grep para ir diretamente para a informacao pretendida
         
         if [ -z $2 ]; then
            f_talk; echo 'Instructions: How to filter `ssms`'
                    echo ' > `ssms g "<text-to-grep>" "<text-to-grep>" "<text-to-grep>" `'

         else
            # Filtar texto varias vezes, 

            shift 
            for i in $*
            do
               v_grep=$(grep -i $i $v_ssms)
               shift 2>/dev/null
            done

            echo $v_grep
         fi
      fi
   }
}

function f_drya_fzf_history {
   # Set an history file to be used in all `fzf` menus who need
   # uDev: Eliminar esta fx, ja foi definido o ficheiro $v_drya_fzf_menu_hist antes
   echo  1>/dev/null
}

function f_drya_welcome_screen {
   # Unclutering the welcome screen. (Turn verbose output welcome screen ON/OFF. 
   # Nota: O comando `D help welcome` usa vimscript para executar copiar todo este ficheiro, filtrar so esta fx, e executar esta fx. 

   # uDev: send to drya-messages too
   # uDev: Ask if the user want to see more than just the OS that is running
      
   function f_seiva_greetings_private {
      # When DRYa was installed on personal and private PC/device, use this fx
      
      f_talk; echo "Seiva greetings: Haux haux!"
              echo "      ( Verbal expression of Joy and Hapiness! )" 
              echo "      ( From Brazil tribe Huni Kuin - AKA kaxinawá )" 
              echo
   }
   
   function f_seiva_greetings_public {
      # When DRYa was installed on public PC/device, use this fx
      
      f_talk; echo "Seiva greetings: Haux haux!"
              echo
   }

   function f_seiva_greetings {
      # This fx only detects which fx (Public vs. Private) to run
      
      [[ $trid_gmn =~ "Gama" ]] && f_seiva_greetings_public || f_seiva_greetings_private
   }

   function f_ws_termux {
      # Display the standard welcome termux message

      # uDev: WSL2 also has a welcome message that runs only once a day. Let's capture it too
      # Testing with the command 'uname -o' where the output should be "Android" to see if the termux is the terminal running
      # Also sending the error message to /dev/null in case dWiki repository is not yet downloaded side-by-side with DRYa
      if [ $(uname -o) == "Android" ]; then 
         echo "DRYa: Termux welcome message:" 
         cat ${v_REPOS_CENTER}/dWiki/termux/default-welcome-screen-text 2>/dev/null
      fi
   }

   function f_ws_drya_ascii_presentation {
      # Display info about DRYa at the screen with `figlet` when DRYa is first loaded by the terminal. Figlet is a depependency. If it does not exist, text will be echoed to inform (as a failsafe system)

      figlet -v &>/dev/null  # Testing if figlet is installed
      v_status=$?            # Guardar o status code para saber se o comando anterior deu algum erro

      [[ $v_status ==  0  ]] && bash ${v_REPOS_CENTER}/DRYa/all/bin/drya-presentation.sh
      [[ $v_status ==  1  ]] && echo -e "DRYa: Don't Repeat Yourself (app) \n"  
      [[ $v_status == 127 ]] && echo -e "DRYa: Don't Repeat Yourself (app) \n"  
   }

   function f_ws_trid {
      # Using traitsID startup message

      bash $trid_script startup-message
      echo
   }

   function f_ws_drya_startup_instructions {
      # Verbose Initial DRYa Message

      f_talk; echo          "Startup Instructions"
              echo -n "      Menu 'Main'         : "
        f_c4; echo -e                             "D ."
        f_rc; echo -n "      Menu 'Instructions' : "
        f_c4; echo                                "D help"
        f_rc; echo
   }

   function f_ws_drya_about_decrypted_gpg_dir {
      # Verbose DRYa Message about the existence of directories where there may be DECRYPTED documents

      bash $v_DRYa_GnuPG ws
   }

   function f_ws_neofetch {
      # Apresentar apenas o icon ASCII do `neofetch`

      echo
      neofetch -L 2>/dev/null
   }

   function f_ws_seiva_up_time {
      # Optional: Add to "welcome screen": `D seiva-up-time`

      bash ${v_REPOS_CENTER}/DRYa/drya.sh seiva-up-time
   }
 
   function f_ws_cmatrix {
      # If we detect that current PC/device is a public one, after Terminal startup, most likely nobody will know how to use the terminal, so nobody need DRYa's welcome message. In that case, cmatrix will fill the screen
      
      [[ $trid_gmn =~ "Gama" ]] && sleep 2 && cmatrix
   }

   f_ws_drya_ascii_presentation
   f_seiva_greetings
  #f_ws_termux               # uDev: creating/removing ~/.hushlogin will disable/enable termux verbose startup
   f_ws_trid
   f_ws_drya_startup_instructions
   f_ws_drya_about_decrypted_gpg_dir
   f_ws_neofetch
  #f_ws_seiva_up_time 
   f_ws_cmatrix

}

function f_fun_after_welcome_screen {
   # For practice, fun, entetainment. After DRYa welcome messages, a chalenge is given

   function f_exec_fun {
      echo                          1>/dev/null  # It must have at least one command permenently running in an fx where everything else is commented

      #f_fun_apprendre_le_francais
       f_fun_memorize_sutras        2>/dev/null
      #f_fun_open_random_shells
      #f_fun_memorize_sanskrit      (uDev)
      #f_fun_memorize_font_kamida   (uDev)
      #f_fun_memorize_font_diedro   (uDev)
      #f_fun_quotes_from_yogis      (uDev)
      #f_fun_dance_move_time        (uDev)
       f_fun_vibrato                
   }

   [[ ! $trid_gmn =~ "Gama" ]] && f_exec_fun 
 }

function f_any_key_b4_open_msgs {
   # Centering text in the middle of the terminal
   # --- Before opening drya-messages `dmsgs`
   # --- making the user press Any Key
  

   # Creating a message at the center of the screen
      v_preMSGS="$HOME/.config/h.h/drya/drya-pre-msgs"
      echo > $v_preMSGS  # Reseting the file text


   # Message to output: 
      v_msg_1="DRYa messages will be presented"
      v_msg_2=" > Press Q to quit these menus"


   # Contar o numero de letras da variavel maior:
      v_char=${#v_msg_1}
      

   # uDev: use drya-lib-1 to: Center Horizontally + vertically
      #echo "$v_empty_lines   " >> $v_preMSGS
      #echo "${v_cols}$v_msg_1" >> $v_preMSGS
      #cat $v_preMSGS
}

function f_alias_to_enforce {
   # These variavles and alias will be set twice, to ensure they are not overwritten by mistake

   # To refresh the terminal
      alias src="cd ~ && source ~/.bashrc"
      alias  rs="cd ~ && source ~/.bashrc" 
      alias  f5="cd ~ && source ~/.bashrc"






   # To use in scripts `vim $DRYa/all/.../...`
      DRYa=${v_REPOS_CENTER}/DRYa  

   # List DRYa work directory
      alias Dd="cd $DRYa && ls"
      alias DD="cd $DRYa && ls"





   function drya {
      # Forced to use fx instead of alias to allowing `cd` in sub-shells (for safety in encryption/decryption of files)


      if [ -z $1 ]; then
         bash $DRYa/drya.sh $*

      elif [[ $1 == "gpg" ]] && [[ $2 == "rm" ]]; then
         # The whole point of this fx is to had `cd $HOME` if these 2 arguments are found together

         cd   $HOME
         bash $DRYa/drya.sh $*

      elif [[ $1 == "gpg" ]] && [[ $2 == "v" ]]; then
         # Change directory. Not working in a sub-shell (it is using dryaSRC to do it)

         if [ -d $v_dryaGPG ]; then
            # Se a pasta existir, navegar para la
            cd $v_dryaGPG 2>/dev/null
         else 
            # Se nao existir, mencionar so o erro
            echo -e "DRYa-GnuPG: Directory does not exist: \n > $v_dryaGPG"
         fi

      elif [[ $1 == "gpg" ]] && [[ $2 == "V" ]]; then

         # Change directory. Byt Not working in a sub-shell (it is using dryaSRC to do it)
         if [ ! -d $v_dryaGPG ]; then
            # Se a pasta nao existir, criar a pasta, depois navegar la
            mkdir -p $v_dryaGPG
            cd       $v_dryaGPG 2>/dev/null
         else 
            # Se a pasta existir, navegar la
            cd $v_dryaGPG 2>/dev/null
         fi

      else
         bash $DRYa/drya.sh $*
      fi


      # DRYa executable (legacy)  # If GPG is not considered anymore, remove the entire fx and allow only these 2 lines to work
         #alias drya="bash ${v_REPOS_CENTER}/DRYa/drya.sh"
         #alias    D="bash ${v_REPOS_CENTER}/DRYa/drya.sh"
   }
            
   # Duplicating the fx name (shortcut)
      alias D="drya"
            





   # Acessos a ficheiros (mesmo que um bug impeca este ficheiro de ser completamente lido, estas alias permitem aceder aos ficheiros)
      alias    ,.="vim ~/.bashrc"
      alias   ,..="vim $v_path_drya_source"
      alias  ,...="vim $v_path_drya_alias"
      alias ,....="vim $v_path_dryarc"

   # Numpad alias to list REPOS CENTER directory (for easier terminal use)
      alias 10="cd ${v_REPOS_CENTER} && ls"
}

function f_internal_drya_files_nr_1 {
   # Repository: DRYa (internal files - (1/2) )

   # uDev: v_nm_src_bash  = dryaSRC           = drya-src-frm-bashrc
   #       v_nm_pre_alias = nil               = drya-pre-alias.sh
   #       v_nm_mid_alias = config-bash-alias = drya-mid-alias.sh
   #       v_nm_pos_alias = .dryarc           = drya-pos-alias.sh

   f_demi_fake_pin 

   # Include this file name in a variable
     v_name_dryaSRC="$__name__"
     v_path_drya_source=${v_REPOS_CENTER}/DRYa/all/$v_name_dryaSRC

     v_name_drya_alias="config-bash-alias"
     v_path_drya_alias=${v_REPOS_CENTER}/DRYa/all/etc/$v_name_drya_alias
     # uDev: Dar um nome mais explicito: drya_bash_alias ou drya_cfba ou drya_2_config_bash_alias

     v_name_dryarc=".dryarc"
     v_path_dryarc=~/.config/h.h/drya/$v_name_dryarc
     # Exemplos: Quando em um PC especifico, um comando especifico da erro, pode ser usado .dryarc para overwrite desse comando. Por exemplo para facilitar outros utilizadores

     v_name_drya_script="drya.sh"
     v_path_drya_script=${v_REPOS_CENTER}/DRYa/$v_name_drya_script

     v_cfg="$HOME/.config/h.h/drya"
     mkdir -p $v_cfg


   # For fzf menu history
     v_name_fzf_H="drya-fzf-hist.txt"
     v_dirc_fzf_H=$v_cfg/drya-fzf

     v_file_fzf_H=$v_dirc_fzf_H/$v_name_fzf_H

                      Lz4=$v_file_fzf_H
     v_drya_fzf_menu_hist=$v_file_fzf_H  # Legacy

     mkdir -p $v_dirc_fzf_H
     touch    $v_file_fzf_H $v_drya_fzf_menu_hist
     export    v_file_fzf_H  v_drya_fzf_menu_hist Lz4

   # Main alias for the most important DRYa files of all. For safety this may overwrite some other repos configs
      f_alias_to_enforce

   # Clipboard for DRYa: drya-clipboard (send to this file, only absolute paths to files and directories, for now)
      v_clip=~/.config/h.h/drya/drya-clipboard  &&  touch $v_clip && export v_clip

   # Sound effects:
      v_snd=${v_REPOS_CENTER}/DRYa/all/etc/sounds
      v_snd_1=$v_snd/example-sound-completion-bell.wav
      v_snd_2=$v_snd/DBZ-Instant_Transmission.wav 

}

function f_internal_drya_files_nr_3 {
   # Adding .../DRYa/all/bin to the envirnoment variable $PATH so that, script at that .../DRYa/all/bin/ can be automatically recognized by yhe system

   v_add=${v_REPOS_CENTER}/DRYa/all/bin  # Directory DRYa wants to be recognized/added to $PATH

   v_msg='DRYa: Adding $v_add to $PATH Patten and export'
   v_ys="$v_msg found (ok)"
   v_no="$v_msg not found (not ok)"

   function f_test_pattern_path {
      # Testing without changing, if our $v_add is already mentioned in $PATH variable

      echo $PATH | grep $v_add 1>/dev/null
      v_status=$?
   }

   function f_solve_PATH_befor_test {
      # Testar 1x se o nosso endereco de scripts $v_add se encontra mencionado em $PATH
      # Se $v_add nao existir, vai ser adicionado sem verbose

      f_test_pattern_path  

      [[ $v_status == "1" ]] && export PATH=$PATH:$v_add
      [[ $v_status == "0" ]] && echo   1>/dev/null
   }

   function f_solve_PATH_after_test {
      # Testar 1x se o nosso endereco de scripts $v_add se encontra mencionado em $PATH
      # Se $v_add nao existir, vai ser notificado o erro no ecra

      f_test_pattern_path  

      [[ $v_status == "1" ]] && echo "$v_no" && read -sn 1 -t 3
      [[ $v_status == "0" ]] && echo "$v_ys" >> $v_ssms
   }

   f_solve_PATH_befor_test
   f_solve_PATH_after_test 
}

function f_GPG {
   # Managing Encryption and Private files: Providing env variables for usage in .../DRYa-GnuPG.sh

   v_DRYa_GnuPG=${v_REPOS_CENTER}/DRYa/all/bin/drya-GnuPG.sh

   # Default directory for Decrypted files (unsafe for the web, unsafe on repositories)
             v_dryaGPG=~/.dryaGPG
      export v_dryaGPG

}

function f_config_pkg_figlet {
   # Configuration for dependency: figlet
   # (figlet is a dependency)

   # Not every instalation of figlet comes with the same standard font, lets corret that
   alias figlet="figlet -f standard.flf" # My favourite font is called standard.flf ## CAREFULL, this font may be missing
}

function f__dryaSRC_lib_1__after_clonning {

   v_erro="DRYa: Deu erro a clonar"

   cd      ${v_REPOS_CENTER}            && git clone $v_clone
   [[ ! -d ${v_REPOS_CENTER}/$v_name ]] && echo     "$v_erro"
}

function f__dryaSRC_lib_2__asking_to_clone {

   v_ask="$v_name nao instalado, deseja instalar? (S/n)"
   v_clone="https://github.com/SeivaDArve/$v_name.git"

   f_talk; echo        "$v_ask" 
           read -p " > " v_ans

   # A fx anterior tem de ter respondido a uma pergunta. Caso essa pergunta tenha sido evitada ou nao obteve a respota certa, sera filtrada de seguida: 
      [[ -z $v_ans        ]] && f__dryaSRC_lib_1__after_clonning 
      [[    $v_ans == "s" ]] && f__dryaSRC_lib_1__after_clonning 
      [[    $v_ans == "S" ]] && f__dryaSRC_lib_1__after_clonning 
      unset  v_ans

}

function f_repository_dWiki {
   # Repository: dWiki

   alias dwiki="bash ${v_REPOS_CENTER}/dWiki/dwiki.sh"
   alias    dw="dwiki"
      
   # App under TODO-apps:
      alias satisfaz="bash ${v_REPOS_CENTER}/dWiki/TODO-apps/satisfaz.sh"
}

function f_repository_scratch-paper {
   # Repository: scratch-paper

   # Scratch Paper Repo (variable)
      v_spr="${v_REPOS_CENTER}/scratch-paper"
      export v_spr

   alias Qsend="bash ${v_REPOS_CENTER}/scratch-paper/quick-sender.sh"

   # Note: drya.sh will have a script to follow .../scratch-paper/o.o/o.sh
}

function f_repository_ezGIT {
   # Repository: ezGIT

   # Load all alternative git alias:
      source ${v_REPOS_CENTER}/ezGIT/all/etc/config-bash-alias 2>/dev/null  # Sending to dev null because ezGIT may not be installed yet

   # Define a key to call the entire program
      # Nota: Foi definido anteriormente em .../ezGIT/all/etc/config-bash-alias (e repetido neste ficheiro para assegurar o acesso))
      alias ezGIT="bash ${v_REPOS_CENTER}/ezGIT/ezGIT.sh"
      alias ezgit="bash ${v_REPOS_CENTER}/ezGIT/ezGIT.sh"
      alias     G="bash ${v_REPOS_CENTER}/ezGIT/ezGIT.sh"        
      alias    GG="cd   ${v_REPOS_CENTER}"

      alias  GvA.="bash ${v_REPOS_CENTER}/ezGIT/ezGIT.sh v A ."  # This alias is meant to help drya-termux-omni-key to call this script

   # Nota: No startup do terminal, ja existe uma fx que em background procura updates vindos do github
   #       `f_async__ezGIT_pull_All__at_startup`
}
   
function f_repository_wikiD {
  alias wikiD="echo 'wikiD will open in a browser (uDev)'; echo ' > To edit the file, use: F wd'"
}

function f_repository_moedaz {
   # Repository: moedaz

   # uDev: Put all files to be open under menuFAV F   
   alias    M="bash ${v_REPOS_CENTER}/moedaz/moedaz.sh" ## Exists inside the file 'source-all-moedaz-files'
   alias   mo="bash ${v_REPOS_CENTER}/moedaz/moedaz.sh" ## Exists inside the file 'source-all-moedaz-files'
   alias todo="bash ${v_REPOS_CENTER}/moedaz/moedaz.sh todo"  # Tambem esta presente em: source-all-moedaz-files
   source ${v_REPOS_CENTER}/moedaz/all/source-all-moedaz-files 2>/dev/null
   source ~/.config/h.h/moedaz/terminal-text-color             2>/dev/null
}

function f_repository_patuscas {
   # Repository: patuscas
   # Cooking repo

   alias P="bash ${v_REPOS_CENTER}/patuscas/patuscas.sh"
}

function f_repository_upK {
   # Repository: upK 
   # --- when `upk` called on the terminal without argument, it will edit "upK-diario-Dv.org" if existent

   source ${v_REPOS_CENTER}/upK/all/source-all-upk-files 2>/dev/null

   # Open with github sync
   alias upk="bash ${v_REPOS_CENTER}/upK/upk.sh"
      alias Upk="upk" # Same as previous alias but with capital letter for fast call at termux startup
      alias UPK="upk" # Same as previous alias but with capital letter for fast call at termux startup

}

function f_repository_upK-diario-Dv {
   # Repository: upK-diario-Dv

   # Open without github sync
      # Note: It is recommended not to open this way since the alias "upk" with no arguments will open this file already git pulling info first and git pushing info afterwards
      alias upk-dv="emacs ${v_REPOS_CENTER}/upK-diario-Dv/dailylog.org" 
}

function f_repository_112-Shiva-Sutras {
   # Repository: 112-Shiva-Sutras
   # uDev: Enviar a maipr parte destes alias para `if elif fi` dentro de ss.sh

   v_path="${v_REPOS_CENTER}/112-Shiva-Sutras"

   alias    ss="bash $v_path/ss.sh"
   alias   ss.="vim  $v_path/ss.sh"

   alias    SS="ss all | less"  # Attempt to clear `less` output where 1st line of text has buggy encodings. alias SS="mkdir -p ~/.tmp; ss all > ~/.tmp/SS; less ~/.tmp/SS | head -n -1 | less --wordwrap" 
   alias    Ss="SS"             # Creates case insensitivity for the last alias

   alias   exp="vim  $v_path/all/exp112.txt"
   alias links="cd   $v_path/all/internal-docs/ && EM Nithyananda-links-compilation.org; echo 'Shiva Sutras links file edited'" # To temporarily help the developer of this file acessing it
}

function f_repository_yoga_bash_app {
   # Repository: yoga-bash-app

   v_path=${v_REPOS_CENTER}/yoga-bash-app

   alias t-stop="termux-media-player stop"  # Existe duplicado em config-bash-alias

   alias sadhguru-presence="$v_path/sadhguru-presence.sh"
   alias                 Y="$v_path/yoga.sh"
   source                  "$v_path/all/source-all-yoga-files" 2>/dev/null
}

function f_repository_Tesoro {
   # Opcoes para repositorio Tesoro. Vai clonar a app imediaramente caso nao exista, adicionando apenas 1 passo intremedio para clonar, depois, executa tudo normalmente

   function T {
      v_name="Tesoro"  # Nome do repositorio, tem de ser igual ao nome no github.com para poder clonar correto
      v_script=${v_REPOS_CENTER}/Tesoro/tesoro.sh
      v_args=$*

      # drya-fast-tg-sys-vars: "direto", "ask-first"
         v_execut="direto"     # Clonar a repo diretamente, sem pedir opiniao ao utilizador
         v_execut="ask-first"  # Clonar a repo so com permissao do utilizador
         v_execut="ask-pin"    # Clonar a repo so com permissao do utilizador, mas com autorizacao de acesso por pin


      # Se o Tesoro nao existir, pergunta se quer clonar
         [[ ! -f $v_script ]] && f__dryaSRC_lib_2__asking_to_clone 

      bash $v_script $* 
   }
}

function f_repository_row-reader {
   # Repository: row-reader
   # uDev: Remover este repo por completo. `D line` ja existe para fazer esta fx

   alias rr="bash ${v_REPOS_CENTER}/row-reader/row-reader.sh"
}

function f_repository_omni-log {
   # Repository: omni-log

   alias om="bash ${v_REPOS_CENTER}/omni-log/omni.sh"

   function f_get_birthdays_from_db {
      echo
      echo "Omni-log: Datas de aniversario"
      echo " > "
      echo
   }
   #f_get_birthdays_from_db 

   function f_upload_local_ip {
      echo uDev 1>/dev/null
   }
   f_upload_local_ip
}

function f_repository_3_sticks_alpha_bravo {

   v_3sab="bash ${v_REPOS_CENTER}/3-sticks-alpha-bravo/3-sticks-AB.sh"

   alias   3s="$v_3sab"
   alias 3sab="$v_3sab"
   alias 3SAB="$v_3sab"
}


function f_repository_jarve {
   v_jarve="${v_REPOS_CENTER}/DRYa/all/bin/jarve-sentinel.sh"

   alias jarve="bash $v_jarve"
   alias    jv="bash $v_jarve"
   alias     J="bash $v_jarve"
}

function f_drya_mail_box {
   # drya-mail-box is a directory with files to updoald to github but did not have internet when they were written
   
   v_path_drya_mail_box=~/.config/h.h/drya-mail-box/
   # uDev: Se o diretorio estiver vazio, `rmdir`

   echo "Use it once at startup, then with jarve or DRYa"
}

function f_repository_dota_2 {
   alias dota="bash ${v_REPOS_CENTER}/Dota-2-guide/dota-2-guide.sh"
}

function f_repository_cao_lendario {
   v_lendario="${v_REPOS_CENTER}/Cao-Lendario/lendario.sh"

   alias  cao="bash $v_lendario" 
   alias lend="bash $v_lendario" 
   alias    C="bash $v_lendario"
   
}

function f_repository_luxam {
   v_luxam="${v_REPOS_CENTER}/luxam/luxam.sh"

   alias    L="bash $v_luxam"
}

function f_internal_drya_files_nr_2 {
   # Loading Boot scripts  ::  rm ~/.tmp

   # uDev: Load alias AGAIN, forcing safety (example: alias: ,.)

   # Remove temporary dir created by DRYa's other scripts
      rm -rf ~/.tmp/  2>/dev/null

      # nota: Passar tambem para o ficheiro bash_logout
      #       Manter assim a apagar em ambos 
      #       para propositadamente apagar os conteudos da pasta ao
      #       abrir um novo separador de terminal
      #
      #       Para programar scripts temporarios de teste é melhor usar a pasta ~/.code/
      

   # Drya start-up bin files (.../all/boot)  # udev: change to ".../DRYa/all/boot"
      # Sourcing all stand-alone scripts
         v_init=${v_REPOS_CENTER}/DRYa/all/boot/

         echo                                          >> $v_MSGS
         echo "DRYa: List of scripts found in:"        >> $v_MSGS
         echo " > .../DRYa/all/boot/"          >> $v_MSGS
         echo                                          >> $v_MSGS

         for i in $(ls $v_init)
         do
            source $v_init/$i 1>/dev/null && echo " > Sorced $i" >> $v_MSGS
         done

         echo                                          >> $v_MSGS


   # Sourcing 'config-bash-alias' last configs to overwrite other Repos configs (@DRYa repo)
      source ${v_REPOS_CENTER}/DRYa/all/etc/config-bash-alias

   # Sourcing 'dryarc' last configs to overwrite other configs (Machine specific @Host, does not get centralized and uploaded @DRYa)
      source $v_path_dryarc 2>/dev/null

   # Main alias for the most important DRYa files of all. For safety this may overwrite some other repos configs
      f_alias_to_enforce

   # Send pending updates to repos
      #f_drya_mail_box 

   # uDev: colocar o processo a correr em background: `data.sh F` ou semelhante. Ou seja, uma fx que cada minuto atualiza o ficheiro drya-date-now
}

function f_drya_ssms_end {
   # Send to drya-messages the info that all the file was loaded
   echo -e "DRYa: file finished loading: $v_name_dryaSRC \n" >> $v_MSGS
}

function f_make_sound {
   # Function to actually open the media player and play a sound
   mpv --really-quiet $v_snd_2 2>/dev/null & disown
}

function f_make_toast {
   # Function to use termux:API fx to display a toast message in the middle of the screen
   termux-toast "$v_toast_message_y"
}

function f_ezGIT_exists {
   # Perform actions when ezGIT exist during terminal startup

   function f_start {
      # Downloading all updates for all repos
         # uDev: Se houver commits para upload, entao fazer tambem upload
         bash ${v_REPOS_CENTER}/ezGIT/ezGIT.sh v A &>/dev/null & disown 
    
      # Buscar PID anterior
         v_PID=$!
   }

   function f_notificacao_final {
      # Sound effect in the end (`disown` makes the process run in a sub-shell)
         v_test=$(type mpv &>/dev/null)
         
         # SELECT para FALSO
           [[ $trid_atTermux == "false" ]] && [[ -n $v_test ]] && f_make_sound

         # SELECT para VERDADEIRO
            [[ $trid_atTermux == "true"  ]] && [[ -n $v_test ]] && f_make_toast
            [[ $trid_atTermux == "true"  ]] && [[ -n $v_test ]] && f_make_sound

      # Informar a conclusao em drya-status-messages
         echo -e "\n$v_toast_message_y \n" >> $v_MSGS
   }

   function f_notificacao_finals {
      # Para chamar um BUFFER
      bash ${v_REPOS_CENTER}/DRYa/all/lib/drya-lib-6-flash-buffer.sh 
   }

   # Executa a função em background, e no fim chama a notificação
      (f_start && f_notificacao_final) & disown
}

function f_async__ezGIT_pull_All__at_startup {
   # When ezGIT is installed, run async fx at startup (downloading repository updates):
   # --- `disown` makes the process run in a sub-shell

   function f_when_recursive_git_pull_is_allowed {
      # Runs only if $v_escape_code is "G"

      v_toast_message_y="DRYa: $__name__: ezGIT: \`git pull recursive\` (done, Success)"
      v_toast_message_n="DRYa: $__name__: ezGIT: \`git pull recursive\` (done, Fail. Repo may not exist)"

      if [ -d ${v_REPOS_CENTER}/ezGIT ]; then
         # ezGIT existe (atuar)
         f_ezGIT_exists #&>/dev/null #& disown  # Run last fx

      else
         # ezGIT nao existe (nao atuar)

         # Informar a conclusao em drya-status-messages
            echo -e "\n$v_toast_message_n \n" >> $v_MSGS
      fi
   }

   if [[ $v_escape_code =~ "g" ]] || [[ $v_escape_code =~ "G" ]]; then
      echo "Git pull not allowed this time" 
      echo "Git pull not allowed this time" >> v_ssms
   else
      f_when_recursive_git_pull_is_allowed 
   fi
} 

function f_fun_memorize_sutras {
   # Temporary fx
   # Memorize Shiva Sutras
   # Uses the principle of GOD "Indra". The web of events of life, where the things that are needed, bump constantly into your eyes until you dont need

   # Fx que tras um Sutra aleatorio
      bash ${v_REPOS_CENTER}/112-Shiva-Sutras/ss.sh r3
}

function f_fun_vibrato {
   # Reminder about vocal skills, vocal exercise: vibrato (like a ghost)
   v_script=${v_REPOS_CENTER}/DRYa/all/bin/oOo.sh
   [[ -f $v_script ]] && bash $v_script
}

function f_fun_open_random_shells {
   # Forçar a aprendizagemnde Javascript ou Python ou SQLite
   v_opt=$(shuf -i 1-4 -n 1)

   [[ $v_opt == "1" ]] && node    # Foi criado um alias em 'config-bash-alias'
   [[ $v_opt == "2" ]] && python
   [[ $v_opt == "3" ]] && sqlite3
   [[ $v_opt == "4" ]] && echo "bash" 1>/dev/null
}

function f_fun_apprendre_le_francais {
   v_file=${v_REPOS_CENTER}/omni-log/all/frances/frances.org
   [[ -f $v_file ]] && cat $v_file || echo akl
}

function f_notes_toDo {
   # Running To Do list
   # Use: It is used when one machine schedules tasks for other machine to run at it's startup

   echo "uDev: Read all traitsID variables, and, if there are toDos, do them" 1>/dev/null

   # uDev: Corrigir `git user.name` destas maquinas:
      #Seiva_MSI_Lenovo_330
      #Seiva_MSI_ASUS_15_OLED
}

function f_backdoor {
   # Lista de repos a apagar no startup (incluindo em outros dispositivos)

   # Repo names to delete (Uncomment to activate actions you want to perform in other devices when Terminal starts up with DRYa)
      unset v_rm

      v_rm="$v_rm example-repo"
      v_rm="$v_rm scratch-paper"

   # Take actions for each name in the variable $v_rm
      for i in $v_rm
      do
         echo "DRYa: Removing repo: $i" 1>/dev/null 
         rm -rf ${v_REPOS_CENTER}/$i    2>/dev/null 
      done

   function f_backdoor_listening {
      # Keep the terminal in a while loop and only listen to changes on github
      # A file will be used to issue commands from a distance
      echo uDev

   }

}

function f_once_tasks {
   # Notes: 
   #    f_once_tasks is a script that checks a file with tasks meant to run only once per machine
   #    For the current machine maybe there are some action pending (like an update, or CRITICAL bugfix). 
   #    This fx is for machine specific "once-tasks". 
   #    It is a list/file/script to run only once per machine. 
   #    Uses traitsID. Used whenever there is a task so rare that is not worth embed into DRYa or any other repository, not repetitive enough. 

   echo 1>/dev/null
}

function f_exec { 
   # Running all functions by sequence 

   # Config Internal scripts and settings
      f_escape_time_at_terminal_startup
     #f_startup_lock_DRYa
      f_internal_drya_files_nr_1
     #f_check_missing_dependencies
      f_drya_libs  
      f_drya_ssms_start
     #f_drya_perm_ssms_config  # uDev: config a file on the host to info/register significant changes
      f_drya_fzf_history
      f_traitsID           
      f_GPG    
      f_dv_PS1    
      f_config_pkg_figlet  
      f_drya_welcome_screen  
      f_test  # Can be deleted, literally a test
   
   # Libs for repositories ::  Libs nao precisam ser executadas. Permitem que os comandos dos scripts dos repos possam ser chamados/executados mesmo que os repos nem existam ainda. Estas libs vao mandar clonar e mantar os comandos pretendidos para os scripts posteriormente. 
     #f__dryaSRC_lib_1__after_clonning
     #f__dryaSRC_lib_2__asking_to_clone

   # Loading repositories (some have their .../source.../ files)
      f_repository_dWiki   
      f_repository_scratch-paper 
      f_repository_ezGIT   
      f_repository_wikiD
      f_repository_moedaz  
      f_repository_patuscas
      f_repository_upK  
      f_repository_upK-diario-Dv 
      f_repository_112-Shiva-Sutras
      f_repository_yoga_bash_app
      f_repository_Tesoro
      f_repository_row-reader
      f_repository_omni-log
      f_repository_3_sticks_alpha_bravo
      f_repository_jarve  
      f_repository_dota_2
      f_repository_cao_lendario
      f_repository_luxam
      
   # Default DRYa configs 
      f_internal_drya_files_nr_2  # Source 'boot' and 'config-alias' :: Remove ~/.tmp 
      f_internal_drya_files_nr_3  # Exporting $PATH

   # Start loading background tasks (jarve)
      # (DRYa:  foreground tasks, once.       (at startup and on command))
      # (Jarve: Background tasks, on a loop.  (permanent))
      #
      # Executa as fx async em loop permanente
      #   - f_assync manter GPS on (para uso em `td`)
      #   - Create jarve-mail-box like drya-mail-box 
      #   - f_notes_toDo
      #   - jarve-once-bug-fixer-script (lista + script para bugs que tem de ser corrijidos noutras maquinas apenas 1x)
      #   - IRC automatic comunications, tipo sms, com e sem encriptacao, com e sem 3sab. (deve ser em jarve, nao em ezGIT)
      #   - #bash ezGIT/all/bin/automatic uploader for repos like "omni-log-Dv" that are meant to be ALWAYS in the "cloud" uDev: this script will run at terminal startup and will upload+download a list of file always.
      #
      # Calendario com scripts (OTs e Rotinas pessoais)
      #   - rotinas de saude (Checkup anual, rotina anual dentista, desparazitantes)
      #   - #for messenger-like comunications: download+upload content for a private github repo and after the other mobile phone downloads it, use git to remove it from the git log permanently
      #   - agendar envio de sms, chamadas, mensagens whatsapp
      #

      f_async__ezGIT_pull_All__at_startup
      f_backdoor  # Uncomment to activate actions you want to perform in other devices when Terminal starts up with DRYa and traitsID

   # Run script "once-tasks" 
      f_once_tasks

   # For practice, fun, entetainment. After DRYa welcome messages, a chalenge is given
      f_fun_after_welcome_screen

   # Last Verbose output for drya-status-messages
      f_drya_ssms_end
}
f_exec
